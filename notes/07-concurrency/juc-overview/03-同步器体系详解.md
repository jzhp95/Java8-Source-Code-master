# Java并发编程(JUC)体系源码深度解析——同步器体系详解

## 三、同步器体系详解

### 3.1 同步器体系概述

#### 3.1.1 同步器在并发编程中的地位

同步器是并发编程的基础构件,它们提供了线程之间协调和同步的机制。在多线程环境中,当多个线程需要访问共享资源或需要协调执行顺序时,同步器就变得至关重要。Java的同步器体系以AbstractQueuedSynchronizer（简称AQS）为核心,构建了一个完整、强大且灵活的同步框架。

AQS是Doug Lea设计的杰作,它被广泛应用于JUC包中的各种同步器实现,包括ReentrantLock、ReentrantReadWriteLock、Semaphore、CountDownLatch、CyclicBarrier等。理解AQS的原理是深入掌握Java并发编程的关键。AQS的设计体现了软件工程的最佳实践,它采用模板方法模式,将同步的通用逻辑与具体实现分离,使得开发者可以轻松创建各种自定义的同步器。

同步器的核心目标是解决多线程环境下的三个基本问题：第一是互斥访问,确保同一时刻只有一个线程能够访问共享资源；第二是协调执行,让多个线程能够按照预期的顺序执行；第三是条件等待,让线程在特定条件满足之前进入等待状态。JUC的同步器体系通过不同的组件分别解决了这些问题。

#### 3.1.2 同步器体系架构

JUC的同步器体系采用分层设计,底层是AQS抽象类,上层是各种具体的同步器实现。这种设计遵循了"依赖倒置"原则,高层模块不依赖低层模块的具体实现,而是都依赖于抽象。

```
AbstractQueuedSynchronizer（AQS）
    │
    ├── 互斥锁实现
    │   ├── ReentrantLock（可重入锁）
    │   │   ├── NonfairSync（非公平锁）
    │   │   └── FairSync（公平锁）
    │   └── ReentrantReadWriteLock（读写锁）
    │       ├── ReadLock（读锁）
    │       └── WriteLock（写锁）
    │
    ├── 共享锁实现
    │   ├── Semaphore（信号量）
    │   │   ├── NonfairSync
    │   │   └── FairSync
    │   ├── CountDownLatch（倒计时锁存器）
    │   └── CyclicBarrier（循环屏障）
    │
    └── 条件变量
        └── Condition（条件变量）
            └── AQS.ConditionObject
```

这种架构设计的精妙之处在于,AQS定义了同步器的核心骨架和通用逻辑,而具体的同步器只需要实现几个抽象方法。这种设计模式被称为"模板方法模式",它极大地简化了同步器的实现,同时保证了各种同步器行为的一致性。

#### 3.1.3 同步器的分类

JUC中的同步器可以分为三大类：互斥锁、共享锁和条件变量。

**互斥锁**是最基本的同步器类型,它确保同一时刻只有一个线程能够访问共享资源。互斥锁的核心特性是"排他性"——一旦某个线程获取了锁,其他线程就必须等待。ReentrantLock是最常用的互斥锁实现,它支持可重入（即同一个线程可以多次获取同一把锁）和公平/非公平两种获取策略。

**共享锁**允许多个线程同时访问共享资源,适用于"读多写少"的场景。Semaphore是共享锁的典型代表,它维护一组许可,线程获取许可后才能访问资源。CountDownLatch和CyclicBarrier也是基于共享锁实现的同步器,它们用于协调多个线程的执行。

**条件变量**用于线程间的更精细的协调。Condition接口提供了await/signal机制,允许线程在特定条件满足之前进入等待状态。与Object的wait/notify机制相比,Condition提供了更多的控制和灵活性。

### 3.2 AQS深度解析

#### 3.2.1 AQS的核心设计理念

AQS的设计灵感来源于"队列同步器"的理念。它使用一个FIFO队列来管理等待获取锁的线程,同时使用一个整数状态（state）来表示锁的可用性。这种设计将锁的获取和释放过程分解为一系列标准化的步骤,使得不同的同步器可以复用相同的逻辑。

AQS的核心思想可以概括为以下几点：第一,**状态管理**,使用一个原子整数（volatile state）来表示同步状态；第二,**队列管理**,使用CLH队列的变体来管理等待线程；第三,**模板方法**,定义获取和释放的通用流程,子类只需实现特定的方法；第四,**CAS操作**,使用Compare-And-Swap原子操作来保证状态修改的原子性。

```java
public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable {
    // 同步状态
    private volatile int state;
    
    // 等待队列的头节点
    private transient volatile Node head;
    
    // 等待队列的尾节点
    private transient volatile Node tail;
    
    // 获取同步状态
    protected final int getState() {
        return state;
    }
    
    // 设置同步状态
    protected final void setState(int newState) {
        state = newState;
    }
    
    // CAS方式设置同步状态
    protected final boolean compareAndSetState(int expect, int update) {
        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
    }
}
```

state字段是AQS的核心,它被声明为volatile以保证可见性。getState、setState和compareAndSetState方法提供了对state的安全访问和修改。子类可以根据自己的需求解释state的含义：对于互斥锁,state为0表示锁可用,大于0表示锁被占用；对于信号量,state表示可用许可数；对于倒计时锁存器,state表示还需等待的计数。

#### 3.2.2 CLH队列详解

AQS使用CLH队列的变体来管理等待获取锁的线程。CLH队列是一种自旋锁队列,它具有高效、公平的优点。队列中的每个节点代表一个等待获取锁的线程,节点之间通过volatile引用链接成双向链表。

```java
static final class Node {
    // 等待状态常量
    static final int CANCELLED =  1;  // 节点已取消
    static final int SIGNAL    = -1;  // 后继节点需要被唤醒
    static final int CONDITION = -2;  // 节点在条件队列中等待
    static final int PROPAGATE = -3;  // 共享模式下传播
    
    // 节点状态
    volatile int waitStatus;
    
    // 前驱节点
    volatile Node prev;
    
    // 后继节点
    volatile Node next;
    
    // 关联的线程
    volatile Thread thread;
    
    // 等待队列中的下一个等待节点（共享/独占模式）
    Node nextWaiter;
    
    // 判断是否为共享模式
    final boolean isShared() {
        return nextWaiter == SHARED;
    }
    
    // 获取前驱节点
    final Node predecessor() throws NullPointerException {
        Node p = prev;
        if (p == null)
            throw new NullPointerException();
        return p;
    }
}
```

Node类是AQS队列的基本组成单元。每个节点包含以下重要字段：

**waitStatus（等待状态）**是节点最关键的属性之一。它有四种有效值：CANCELLED（值为1）表示节点已超时或被取消；SIGNAL（值为-1）表示后继节点需要被当前节点唤醒；CONDITION（值为-2）表示节点在条件队列中等待；PROPAGATE（值为-3）用于共享模式下的传播。

**prev和next指针**构成双向链表,允许在队列中进行双向遍历。这在取消节点时特别有用,可以快速跳过已取消的节点。

**thread字段**保存了与该节点关联的线程。当线程获取锁失败时,会被包装成节点加入队列；当线程获取锁成功时,会从队列中移除。

**nextWaiter字段**在等待队列中用于指向下一个等待节点。在共享模式中,它可能被设置为SHARED常量来表示共享模式。

#### 3.2.3 独占模式获取锁

独占模式是互斥锁的基础。在这种模式下,同一时刻只有一个线程能够获取锁。AQS使用acquire方法作为独占模式获取锁的入口。

```java
public final void acquire(int arg) {
    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

acquire方法的流程可以分解为三个步骤：

第一步,**尝试获取锁（tryAcquire）**。tryAcquire是一个抽象方法,需要子类实现。它负责检查当前状态是否允许获取锁,如果允许则更新状态并返回true。AQS默认实现抛出UnsupportedOperationException,所有具体同步器都需要重写此方法。

第二步,**加入等待队列（addWaiter）**。如果tryAcquire失败,说明锁已被其他线程持有,当前线程需要等待。此时,当前线程被包装成Node.EXCLUSIVE模式的节点,加入等待队列的尾部。

```java
private Node addWaiter(Node mode) {
    Node node = new Node(mode);
    // 快速尝试将节点加入队尾
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    // CAS失败或队列为空,通过自旋加入队列
    enq(node);
    return node;
}

private Node enq(final Node node) {
    for (;;) {
        Node t = tail;
        if (t == null) {
            // 队列为空,初始化队列
            if (compareAndSetHead(new Node())) {
                tail = head;
            }
        } else {
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
```

addWaiter方法首先尝试快速路径：如果尾节点不为空,则直接将新节点链接到尾节点后；如果CAS失败或队列为空,则调用enq方法通过自旋将节点加入队列。enq方法确保节点最终会被加入队列,如果需要还会初始化队列。

第三步,**在队列中等待（acquireQueued）**。节点加入队列后,线程进入自旋等待状态,直到获取到锁或被中断。

```java
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            // 如果前驱是头节点,尝试获取锁
            if (p == head && tryAcquire(arg)) {
                // 获取成功,设置当前节点为头节点
                setHead(node);
                p.next = null; // 帮助GC
                failed = false;
                return interrupted;
            }
            // 检查是否需要阻塞
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

acquireQueued方法的核心是一个自旋循环。线程首先检查前驱节点是否是头节点（头节点是当前持有锁的节点或已释放锁的节点）；如果是头节点,则尝试获取锁；如果获取成功,则将当前节点设为头节点并返回。如果前驱节点不是头节点,或者获取锁失败,则调用shouldParkAfterFailedAcquire方法检查是否应该阻塞。

```java
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL)
        // 前驱节点已设置SIGNAL,可以安全阻塞
        return true;
    if (ws > 0) {
        // 前驱节点已取消,跳过已取消的节点
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus > 0);
        pred.next = node;
    } else {
        // 前驱节点状态正常,但未设置SIGNAL
        // 设置为SIGNAL,下次再尝试
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
```

shouldParkAfterFailedAcquire方法负责检查线程是否可以安全地阻塞。如果前驱节点的waitStatus为Node.SIGNAL,说明前驱节点会在释放锁时唤醒后继节点,当前线程可以安全阻塞。如果前驱节点已取消（waitStatus>0）,则需要跳过这些已取消的节点。如果前驱节点状态正常但不是SIGNAL,则将其设置为SIGNAL后返回false,让当前线程再次尝试获取锁。

```java
private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this);
    return Thread.interrupted();
}
```

parkAndCheckInterrupt方法使用LockSupport.park阻塞当前线程,并返回线程是否被中断。LockSupport是Java提供的线程阻塞工具,它比Object.wait/notify更加灵活。

#### 3.2.4 独占模式释放锁

与获取锁相对应的是释放锁。AQS使用release方法作为独占模式释放锁的入口。

```java
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            // 唤醒后继节点
            unparkSuccessor(h);
        return true;
    }
    return false;
}
```

release方法首先调用tryRelease尝试释放锁。tryRelease是抽象方法,需要子类实现。如果释放成功（tryRelease返回true）,则唤醒后继节点。

```java
protected abstract boolean tryRelease(int arg);

private void unparkSuccessor(Node node) {
    int ws = node.waitStatus;
    if (ws < 0)
        // 清除节点状态
        compareAndSetWaitStatus(node, ws, 0);
    
    Node s = node.next;
    if (s == null || s.waitStatus > 0) {
        // 如果后继节点为空或已取消,从尾节点向前查找
        s = tail;
        while (s != null && s != node) {
            if (s.waitStatus <= 0)
                break;
            s = s.prev;
        }
    }
    if (s != null)
        // 唤醒后继节点
        LockSupport.unpark(s.thread);
}
```

unparkSuccessor方法负责唤醒后继节点。它首先清除头节点的状态,然后查找需要唤醒的后继节点。这里有一个优化：如果后继节点为空或已取消,则从尾节点向前查找,找到最接近头节点的有效节点。

#### 3.2.5 共享模式获取锁

共享模式允许多个线程同时获取锁,适用于读多写少的场景。AQS使用acquireShared方法作为共享模式获取锁的入口。

```java
public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) < 0)
        doAcquireShared(arg);
}
```

共享模式与独占模式的区别在于,tryAcquireShared返回负数表示获取失败,返回0表示获取成功但不传播,返回正数表示获取成功且需要向后传播。

```java
private void doAcquireShared(int arg) {
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r >= 0) {
                    // 获取成功,传播并设置头节点
                    setHeadAndPropagate(node, r);
                    p.next = null;
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

与独占模式不同,共享模式在获取成功后会调用setHeadAndPropagate方法,不仅设置当前节点为头节点,还会向后传播,唤醒后续等待的共享节点。

```java
private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head;
    setHead(node);
    // 如果还有可用资源,尝试唤醒后继节点
    if (propagate > 0 || h == null || h.waitStatus < 0 ||
        (h = head) == null || h.waitStatus < 0) {
        Node s = node.next;
        if (s == null || s.isShared())
            doReleaseShared();
    }
}
```

setHeadAndPropagate方法将当前节点设为头节点后,会检查是否还有可用的资源。如果有,则尝试唤醒后继的共享节点。

#### 3.2.6 共享模式释放锁

```java
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}

private void doReleaseShared() {
    for (;;) {
        Node h = head;
        if (h != null && h.waitStatus != 0) {
            unparkSuccessor(h);
            if (h == head) // 避免竞态条件
                break;
        }
        if (h == head) // 头节点未变,退出
            break;
    }
}
```

共享模式的释放需要调用doReleaseShared方法,该方法会唤醒所有等待的共享节点。与独占模式不同,共享模式的释放可能需要多次唤醒,因为每次唤醒后可能会有新的节点加入队列。

### 3.3 ReentrantLock详解

#### 3.3.1 ReentrantLock概述

ReentrantLock是Java中最常用的互斥锁实现,它提供了比synchronized关键字更灵活的锁操作。与synchronized相比,ReentrantLock提供了公平/非公平两种获取策略、可中断的获取操作、超时获取、尝试获取以及Condition支持等功能。

```java
public class ReentrantLock implements Lock, java.io.Serializable {
    private final Sync sync;
    
    abstract static class Sync extends AbstractQueuedSynchronizer {
        private static final long serialVersionUID = -5179523762034025860L;
        
        abstract void lock();
        
        final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            } else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0) // 防止整数溢出
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
        
        protected final boolean tryRelease(int releases) {
            int c = getState() - releases;
            if (Thread.currentThread() != getExclusiveOwnerThread())
                throw new IllegalMonitorStateException();
            boolean free = false;
            if (c == 0) {
                free = true;
                setExclusiveOwnerThread(null);
            }
            setState(c);
            return free;
        }
        
        protected final boolean isHeldExclusively() {
            return getExclusiveOwnerThread() == Thread.currentThread();
        }
    }
    
    static final class NonfairSync extends Sync {
        private static final long serialVersionUID = 7316153563782823691L;
        
        final void lock() {
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
        }
        
        protected final boolean tryAcquire(int acquires) {
            return nonfairTryAcquire(acquires);
        }
    }
    
    static final class FairSync extends Sync {
        private static final long serialVersionUID = -3000897897090466540L;
        
        final void lock() {
            acquire(1);
        }
        
        protected final boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                // 公平锁特有的检查：是否有前驱节点
                if (!hasQueuedPredecessors() &&
                    compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            } else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0)
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
    }
}
```

ReentrantLock的内部结构清晰地展示了同步器模式的应用。Sync是抽象基类,定义了通用的获取和释放逻辑。NonfairSync和FairSync分别实现非公平和公平两种策略。

#### 3.3.2 非公平锁实现

非公平锁是ReentrantLock的默认模式。在非公平模式下,线程获取锁的顺序与请求顺序不一致,新到的线程可能直接获取到锁,而等待队列中的线程则需要继续等待。

```java
static final class NonfairSync extends Sync {
    final void lock() {
        // 首先尝试CAS获取锁
        if (compareAndSetState(0, 1))
            setExclusiveOwnerThread(Thread.currentThread());
        else
            // CAS失败,进入等待队列
            acquire(1);
    }
}
```

非公平锁的获取策略采用"先到先得"的原则。当锁可用时,新来的线程可以直接通过CAS获取锁,而不需要考虑等待队列中的线程。这种策略的优点是减少了线程切换的开销,提高了吞吐量；缺点是可能导致等待队列中的线程长时间得不到锁（饥饿现象）。

nonfairTryAcquire方法实现了非公平锁的获取逻辑：首先检查state是否为0,如果为0则尝试CAS获取；如果不为0且当前线程已经是持有锁的线程,则state加1（可重入）；否则获取失败。

#### 3.3.3 公平锁实现

公平锁严格按照等待队列的顺序分配锁。当一个线程请求锁时,如果等待队列中有其他线程在等待,则新来的线程会被加入队列尾部,而不会直接尝试获取锁。

```java
static final class FairSync extends Sync {
    final void lock() {
        acquire(1);
    }
    
    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            // 公平锁特有的：检查是否有前驱节点
            if (!hasQueuedPredecessors() &&
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        } else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc < 0)
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }
}
```

公平锁与非公平锁的唯一区别在于tryAcquire方法。公平锁在获取锁之前会调用hasQueuedPredecessors方法检查等待队列中是否有前驱节点。

```java
public final boolean hasQueuedPredecessors() {
    Node t = tail;
    Node h = head;
    Node s;
    return h != t &&
        ((s = h.next) == null || s.thread != Thread.currentThread());
}
```

hasQueuedPredecessors方法检查当前线程是否有前驱节点。如果头节点和尾节点不同,且头节点的后继节点不为空且不是当前线程,则说明当前线程有前驱节点,不能立即获取锁。

#### 3.3.4 可重入性原理

可重入性是ReentrantLock的一个重要特性。同一个线程可以多次获取同一把锁,而不会发生死锁。state字段记录了锁被获取的次数。

```java
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
```

tryRelease方法在释放锁时,将state减1。只有当state减到0时,才真正释放锁,将持有线程设为null。这意味着持有锁的线程必须释放与获取次数相同的次数,锁才会被完全释放。

#### 3.3.5 Condition支持

ReentrantLock通过newCondition方法创建Condition对象,提供了比Object.wait/notify更灵活的条件等待机制。

```java
public Condition newCondition() {
    return sync.newCondition();
}
```

sync.newCondition()返回的是AQS的ConditionObject实例。ConditionObject是Condition接口的实现,它是AQS的内部类。

### 3.4 ReentrantReadWriteLock详解

#### 3.4.1 读写锁概述

ReentrantReadWriteLock是读写锁的实现,它维护了一对锁：一个读锁和一个写锁。读锁是共享的,多个线程可以同时获取；写锁是排他的,同一时刻只能有一个线程获取。这种设计适用于"读多写少"的场景,可以大大提高并发性能。

```java
public class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializable {
    private final ReadLock readerLock;
    private final WriteLock writerLock;
    final Sync sync;
    
    public ReentrantReadWriteLock() {
        this(false);
    }
    
    public ReentrantReadWriteLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
        readerLock = new ReadLock(sync);
        writerLock = new WriteLock(sync);
    }
    
    public ReadLock readLock() { return readerLock; }
    public WriteLock writeLock() { return writerLock; }
}
```

ReentrantReadWriteLock内部维护了一个Sync实例（可以是公平或非公平）,以及两个Lock实例（ReadLock和WriteLock）。这两个锁都委托给同一个Sync实例进行同步。

#### 3.4.2 读写锁状态设计

读写锁使用一个state字段同时维护读锁和写锁的状态。这需要巧妙地利用state的位布局。

```java
abstract static class Sync extends AbstractQueuedSynchronizer {
    static final int SHARED_SHIFT   = 16;
    static final int SHARED_UNIT    = (1 << SHARED_SHIFT);
    static final int MAX_COUNT      = (1 << SHARED_SHIFT) - 1;
    static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;
    
    static int sharedCount(int c) { return c >>> SHARED_SHIFT; }
    static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; }
}
```

state字段被分为两部分：低16位用于表示写锁的重入次数,高16位用于表示读锁的持有者数量。这种设计允许同时存在多个读锁持有者。

**sharedCount方法**通过无符号右移16位获取读锁的持有者数量。**exclusiveCount方法**通过与EXCLUSIVE_MASK进行与操作获取写锁的重入次数。

#### 3.4.3 读锁实现

读锁是共享锁,允许多个线程同时获取。它通过tryAcquireShared方法实现。

```java
protected final int tryAcquireShared(int unused) {
    Thread current = Thread.currentThread();
    int c = getState();
    if (exclusiveCount(c) != 0 &&
        getExclusiveOwnerThread() != current)
        return -1; // 有写锁且不属于当前线程,获取失败
    
    int readerCount = sharedCount(c);
    if (readerCount == MAX_COUNT)
        throw new Error("Maximum lock count exceeded");
    
    if (readerCount == 0 ||
        (readerCount == SHARED_SHIFT && firstReader == current)) {
        // 第一个读锁或可重入
        if (compareAndSetState(c, c + SHARED_UNIT)) {
            if (readerCount == 0) {
                firstReader = current;
                firstReaderHoldCount = 1;
            } else {
                firstReaderHoldCount++;
            }
            return 1;
        }
    }
    
    // 检查是否需要升级
    if (shouldSpin(firstReaderHoldCount))
        if (sharedCount(getState()) == 0 &&
            exclusiveCount(getState()) == 0 &&
            !compareAndSetState(c, c + SHARED_UNIT))
        return -1;
    
    // 读锁数量加1
    return fullTryAcquireShared(current);
}
```

读锁的获取逻辑相对复杂：如果有写锁且不属于当前线程,则获取失败；如果是第一个读锁或者可重入的情况,则通过CAS获取；否则需要通过fullTryAcquireShared方法处理。

读锁是可重入的,firstReader和firstReaderHoldCount用于跟踪第一个读者的信息,避免为第一个读者创建HoldCounter对象。

#### 3.4.4 写锁实现

写锁是独占锁,同一时刻只能有一个线程获取。它通过tryAcquire方法实现。

```java
protected final boolean tryAcquire(int acquires) {
    Thread current = Thread.currentThread();
    int c = getState();
    int w = exclusiveCount(c);
    if (c != 0) {
        // 已有读锁或写锁
        if (w == 0 || current != getExclusiveOwnerThread())
            return false; // 读锁存在或写锁不属于当前线程
        if (w + acquires > MAX_COUNT)
            throw new Error("Maximum lock count exceeded");
    }
    
    if (compareAndSetState(c, c + acquires)) {
        setExclusiveOwnerThread(current);
        return true;
    }
    return false;
}
```

写锁的获取逻辑：如果state不为0,则要么是读锁存在（w==0）,要么是写锁不属于当前线程（current != getExclusiveOwnerThread()）,这两种情况都获取失败。如果符合重入条件,则通过CAS更新state并设置持有线程。

#### 3.4.5 锁降级

读写锁支持锁降级：一个持有写锁的线程可以先获取读锁,然后释放写锁,最后持有读锁。这种操作是合法的,因为读锁不会阻塞同一线程。

```java
public class LockDowngradeDemo {
    private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
    private final Lock readLock = rwLock.readLock();
    private final Lock writeLock = rwLock.writeLock();
    private Object data;
    
    public Object getData() {
        readLock.lock();
        try {
            return data;
        } finally {
            readLock.unlock();
        }
    }
    
    public Object updateData(Object newData) {
        writeLock.lock();
        try {
            // 锁降级：先获取读锁
            readLock.lock();
            try {
                // 业务逻辑可以使用读锁访问
                data = newData;
                return data;
            } finally {
                // 释放写锁,保留读锁
                writeLock.unlock();
            }
        } finally {
            readLock.unlock();
        }
    }
}
```

注意,上述代码中的锁降级不是标准的锁降级操作。标准的锁降级应该是在持有写锁期间直接获取读锁,然后释放写锁。如果先释放写锁再获取读锁,可能会有其他线程获取写锁,导致数据不一致。

### 3.5 Semaphore详解

#### 3.5.1 信号量概述

Semaphore是信号量实现,用于控制同时访问特定资源的线程数量。信号量维护一组许可,线程获取许可后才能访问资源,访问完成后释放许可。如果许可不可用,线程会阻塞等待。

```java
public class Semaphore implements java.io.Serializable {
    private final Sync sync;
    
    abstract static class Sync extends AbstractQueuedSynchronizer {
        Sync(int permits) {
            setState(permits);
        }
        
        final int getPermits() {
            return getState();
        }
        
        final int nonfairTryAcquireShared(int acquires) {
            for (;;) {
                int available = getState();
                int remaining = available - acquires;
                if (remaining < 0 ||
                    compareAndSetState(available, remaining))
                    return remaining;
            }
        }
        
        protected final boolean tryReleaseShared(int releases) {
            for (;;) {
                int current = getState();
                int next = current + releases;
                if (next < current) // 溢出检查
                    throw new Error("Maximum permit count exceeded");
                if (compareAndSetState(current, next))
                    return true;
            }
        }
    }
    
    static final class NonfairSync extends Sync {
        protected int tryAcquireShared(int acquires) {
            return nonfairTryAcquireShared(acquires);
        }
    }
    
    static final class FairSync extends Sync {
        protected int tryAcquireShared(int acquires) {
            for (;;) {
                if (hasQueuedPredecessors())
                    return -1;
                int available = getState();
                int remaining = available - acquires;
                if (remaining < 0 ||
                    compareAndSetState(available, remaining))
                    return remaining;
            }
        }
    }
}
```

Semaphore的state字段表示可用许可的数量。获取许可时,state减1；释放许可时,state加1。nonfairTryAcquireShared方法使用CAS循环来原子地更新state。

#### 3.5.2 信号量使用示例

```java
public class SemaphoreDemo {
    private final Semaphore semaphore = new Semaphore(5);
    
    public void accessResource() throws InterruptedException {
        semaphore.acquire();
        try {
            // 访问共享资源
            Thread.sleep(1000);
        } finally {
            semaphore.release();
        }
    }
}
```

这个示例创建了一个有5个许可的信号量,最多允许5个线程同时访问资源。acquire方法获取一个许可,如果许可不可用则阻塞；release方法释放许可,如果有等待的线程则唤醒一个。

### 3.6 CountDownLatch详解

#### 3.6.1 倒计时锁存器概述

CountDownLatch是一种同步辅助工具,允许一个或多个线程等待,直到在其他线程中的一组操作完成。它通过一个计数器实现,计数器初始值为线程数,每个线程完成任务后计数器减1,当计数器达到0时,等待的线程被唤醒。

```java
public class CountDownLatch {
    private static final class Sync extends AbstractQueuedSynchronizer {
        Sync(int count) {
            setState(count);
        }
        
        int getCount() {
            return getState();
        }
        
        protected int tryAcquireShared(int acquires) {
            return getState() == 0 ? 1 : -1;
        }
        
        protected boolean tryReleaseShared(int releases) {
            for (;;) {
                int c = getState();
                if (c == 0)
                    return false;
                int nextc = c - 1;
                if (compareAndSetState(c, nextc))
                    return nextc == 0;
            }
        }
    }
    
    private final Sync sync;
    
    public CountDownLatch(int count) {
        if (count < 0) throw new IllegalArgumentException("count < 0");
        this.sync = new Sync(count);
    }
    
    public void await() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
    }
    
    public boolean await(long timeout, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
    }
    
    public void countDown() {
        sync.releaseShared(1);
    }
    
    public long getCount() {
        return sync.getCount();
    }
}
```

CountDownLatch的Sync使用state表示还需要等待的线程数。tryAcquireShared方法返回1（获取成功）当且仅当state为0；tryReleaseShared方法将state减1,当state变为0时返回true以唤醒等待的线程。

### 3.7 CyclicBarrier详解

#### 3.7.1 循环屏障概述

CyclicBarrier是一种同步辅助工具,允许一组线程互相等待,直到所有线程都到达某个屏障点。与CountDownLatch不同,CyclicBarrier可以重复使用,当所有线程都通过屏障后,屏障会重置以供下次使用。

```java
public class CyclicBarrier {
    private static class Generation {
        boolean broken = false;
    }
    
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition trip = lock.newCondition();
    private final int parties;
    private final Runnable barrierCommand;
    private Generation generation = new Generation();
    private int count;
    
    public CyclicBarrier(int parties, Runnable barrierAction) {
        this.parties = parties;
        this.count = parties;
        this.barrierCommand = barrierAction;
    }
    
    public int await() throws InterruptedException, BrokenBarrierException {
        return dowait(false, 0L);
    }
    
    private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            final Generation g = generation;
            
            if (g.broken)
                throw new BrokenBarrierException();
            
            if (Thread.interrupted()) {
                breakBarrier();
                throw new InterruptedException();
            }
            
            int index = --count;
            if (index == 0) { // 所有线程都已到达
                boolean ranAction = false;
                try {
                    final Runnable command = barrierCommand;
                    if (command != null)
                        command.run();
                    ranAction = true;
                    nextGeneration();
                    return 0;
                } finally {
                    if (!ranAction)
                        breakBarrier();
                }
            }
            
            // 等待其他线程
            for (;;) {
                try {
                    if (!timed)
                        trip.await();
                    else if (nanos > 0L)
                        nanos = trip.awaitNanos(nanos);
                } catch (InterruptedException ie) {
                    if (g == generation && ! g.broken) {
                        breakBarrier();
                        throw ie;
                    } else {
                        Thread.currentThread().interrupt();
                    }
                }
                
                if (g.broken)
                    throw new BrokenBarrierException();
                
                if (g != generation)
                    return index;
                
                if (timed && nanos <= 0L) {
                    breakBarrier();
                    throw new TimeoutException();
                }
            }
        } finally {
            lock.unlock();
        }
    }
    
    private void nextGeneration() {
        trip.signalAll();
        count = parties;
        generation = new Generation();
    }
    
    private void breakBarrier() {
        generation.broken = true;
        count = parties;
        trip.signalAll();
    }
}
```

CyclicBarrier使用ReentrantLock和Condition实现,而不是AQS。这是因为CyclicBarrier需要更精细的控制,例如在所有线程到达后执行一个动作,然后唤醒所有等待的线程。

Generation类用于追踪屏障的当前代。每次所有线程通过屏障后,都会创建一个新的Generation对象。broken标志用于表示屏障是否被破坏。

### 3.8 Condition详解

#### 3.8.1 条件变量概述

Condition接口提供了与Object的wait/notify/notifyAll类似的线程协调机制,但功能更强大。一个Lock可以创建多个Condition,每个Condition可以独立地等待和通知。

```java
public interface Condition {
    void await() throws InterruptedException;
    void awaitUninterruptibly();
    long awaitNanos(long nanosTimeout) throws InterruptedException;
    boolean await(long time, TimeUnit unit) throws InterruptedException;
    boolean awaitUntil(Date deadline) throws InterruptedException;
    void signal();
    void signalAll();
}
```

#### 3.8.2 ConditionObject实现

ConditionObject是Condition接口的实现,它是AQS的内部类。

```java
public class ConditionObject implements Condition, java.io.Serializable {
    private transient Node firstWaiter;
    private transient Node lastWaiter;
    
    public final void await() throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        Node node = addConditionWaiter();
        int savedState = fullyRelease(node);
        int interruptMode = 0;
        while (!isOnSyncQueue(node)) {
            LockSupport.park(this);
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
        }
        if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        if (node.nextWaiter != null)
            unlinkCancelledWaiters();
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
    }
    
    public final void signal() {
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        Node first = firstWaiter;
        if (first != null)
            doSignal(first);
    }
    
    private void doSignal(Node first) {
        do {
            firstWaiter = first.nextWaiter;
            if (firstWaiter == null)
                lastWaiter = null;
            if (transferForSignal(first)) {
                // 成功转移节点到同步队列
            }
        } while (firstWaiter != null);
    }
    
    public final void signalAll() {
        if (!isHeldExclusively())
            throw new IllegalMonitorStateException();
        Node first = firstWaiter;
        if (first != null) {
            do {
                firstWaiter = first.nextWaiter;
                if (firstWaiter == null)
                    lastWaiter = null;
                transferForSignal(first);
                first = firstWaiter;
            } while (first != null);
        }
    }
    
    final int fullyRelease(Node node) {
        try {
            return release(node.waitStatus) ? 1 : 0;
        } catch (RuntimeException ie) {
            node.waitStatus = Node.CANCELLED;
            throw ie;
        }
    }
    
    private static final int THROW_IE = -1;
    private static final int REINTERRUPT = 1;
}
```

ConditionObject维护一个条件队列,等待的节点通过nextWaiter链接。当线程调用await时,节点从条件队列转移到同步队列；当线程调用signal时,节点从条件队列转移到同步队列,然后可能被唤醒。

### 3.9 同步器使用最佳实践

#### 3.9.1 锁的选择

选择合适的同步器对于系统性能和可维护性至关重要。

**ReentrantLock vs synchronized:** 如果需要公平锁、可中断锁、超时锁、尝试锁或多个Condition,应该使用ReentrantLock；否则可以优先考虑synchronized,因为它更简洁,JVM也会做更多优化。

**ReentrantReadWriteLock:** 适用于读多写少的场景,可以显著提高并发性能。需要注意锁降级的正确使用。

**Semaphore:** 适用于需要限制并发访问数量的场景,例如数据库连接池、线程池大小控制等。

**CountDownLatch:** 适用于一个线程等待多个线程完成的场景,例如主线程等待所有子任务完成。

**CyclicBarrier:** 适用于多个线程互相等待的场景,例如并行计算的阶段同步。

**Condition:** 适用于需要精细线程协调的场景,例如生产者-消费者模型。

#### 3.9.2 死锁避免

在使用同步器时,需要特别注意死锁问题。

**锁的顺序:** 如果必须获取多个锁,应该始终按照相同的顺序获取。

```java
// 错误的示例：可能导致死锁
public void transfer(Account from, Account to, BigDecimal amount) {
    synchronized (from) {
        synchronized (to) {
            // 转账逻辑
        }
    }
}

// 正确的示例：按账户ID顺序获取锁
public void transfer(Account from, Account to, BigDecimal amount) {
    Account first = from.id < to.id ? from : to;
    Account second = from.id < to.id ? to : from;
    synchronized (first) {
        synchronized (second) {
            // 转账逻辑
        }
    }
}
```

#### 3.9.3 性能优化

**减少锁的粒度:** 将锁的范围限制在必要的代码块内,减少锁的持有时间。

```java
// 粗粒度锁：锁定整个方法
public synchronized void process() {
    long start = System.currentTimeMillis();
    // 计算逻辑
    doSomething();
    long end = System.currentTimeMillis();
}

// 细粒度锁：只锁定必要的代码
public void process() {
    long start = System.currentTimeMillis();
    // 计算逻辑
    doSomething();
    long end = System.currentTimeMillis();
}
```

**使用读写锁:** 对于读多写少的场景,使用读写锁可以提高并发性能。

### 3.10 小结

同步器体系是JUC的核心组成部分,AQS作为同步器框架的基础,提供了强大的同步机制。通过深入理解AQS的原理和各个同步器的实现,我们可以更好地编写高效、线程安全的并发程序。

**核心要点总结：**

第一,**AQS的设计哲学**体现了模板方法模式和策略模式的精髓,通过分离通用逻辑和特定实现,实现了高度的可扩展性和复用性。

第二,**状态管理**是AQS的核心,state字段被不同同步器解释为不同的含义：互斥锁表示持有者,信号量表示可用许可数,倒计时锁存器表示还需等待的计数。

第三,**队列管理**使用CLH队列的变体管理等待线程,通过CAS操作保证队列操作的原子性。

第四,**公平与非公平**的选择影响系统行为,非公平锁有更高的吞吐量,公平锁保证等待时间最长的线程优先获取。

第五,**不同同步器的适用场景**各不相同：ReentrantLock用于互斥访问,ReadWriteLock用于读多写少,Semaphore用于资源限制,CountDownLatch用于线程等待,CyclicBarrier用于阶段同步。

理解这些同步器的内部实现原理,对于编写高质量的并发程序具有重要意义。
