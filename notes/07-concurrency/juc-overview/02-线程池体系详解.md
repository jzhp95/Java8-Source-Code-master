# Java并发编程(JUC)体系源码深度解析——线程池体系详解

## 二、线程池体系详解

### 2.1 线程池概述与设计理念

#### 2.1.1 为什么要使用线程池

在多线程应用程序中,线程的创建和销毁是一项昂贵的操作。频繁地创建和销毁线程会显著影响系统的性能和稳定性。线程池通过复用已创建的线程来执行任务,避免了线程频繁创建和销毁的开销,同时还能够统一管理线程的生命周期,提供线程监控和调优的能力。

**线程池的核心优势包括:**

第一,**资源复用**是线程池最重要的特性。通过预先创建一组线程并反复使用这些线程执行多个任务,避免了每次执行任务时都创建新线程的系统开销。在高并发场景下,这种复用机制能够显著提高系统的吞吐量和响应速度。

第二,**统一管理**使得线程的生命周期可以受到集中控制。线程池提供了对线程的创建、调度、监控和终止的统一管理机制,避免了线程管理混乱的问题。通过配置线程池的参数,如核心线程数、最大线程数、空闲线程存活时间等,可以灵活地控制线程池的行为。

第三,**性能优化**体现在多个方面。线程池避免了频繁创建和销毁线程的系统开销,通过调整线程池的参数可以优化系统性能,同时内置的队列机制可以平滑处理任务的突发流量,防止系统过载。

第四,**可靠性增强**通过线程池的异常处理和优雅停机机制实现。线程池能够捕获线程执行过程中抛出的异常,并提供优雅停机的能力,确保系统在关闭时能够正确处理正在执行的任务。

#### 2.1.2 Java线程池的核心设计

Java的线程池体系采用分层设计,每一层都有明确的职责划分。Executor接口是最顶层的抽象,定义了任务执行的基本契约。ExecutorService接口在此基础上扩展了生命周期管理和任务提交的能力。AbstractExecutorService提供了ExecutorService接口的骨架实现,降低了具体实现的复杂度。ThreadPoolExecutor是线程池的完整实现,提供了丰富的配置选项和生命周期管理。ScheduledThreadPoolExecutor在ThreadPoolExecutor的基础上增加了定时任务和周期任务的支持。ForkJoinPool则是一种特殊的线程池,专为分治任务设计,采用工作窃取算法实现高效的并行计算。

这种分层设计遵循了软件设计的开闭原则和依赖倒置原则,使得整个线程池体系具有良好的扩展性和灵活性。开发者可以通过实现Executor接口创建自定义的执行器,也可以通过扩展ThreadPoolExecutor或ForkJoinPool来满足特定的需求。

### 2.2 核心接口与抽象类

#### 2.2.1 Executor接口分析

Executor接口是整个执行框架的入口,其设计极为简洁,只定义了一个execute方法。这种极简的设计体现了"单一职责"原则,让执行器专注于任务的执行,而将任务提交的细节交给具体的实现。

```java
public interface Executor {
    void execute(Runnable command);
}
```

Executor接口的设计体现了"命令模式"的思想,将任务(Runnable)与执行者(Executor)解耦。这种解耦带来了极大的灵活性,不同的执行策略可以实现不同的执行逻辑。例如,任务可以直接在当前线程执行,也可以提交到线程池执行,还可以延迟执行或批量执行。

在源码中,execute方法的设计非常精妙。参数Runnable代表要执行的任务,方法没有返回值,这意味着任务的执行是异步的,提交者不需要等待任务完成。如果提交者需要获取任务的执行结果,应该使用submit方法,该方法返回Future对象。

**execute方法的执行策略:**

当调用execute方法时,执行器需要决定如何执行传入的任务。这个决策过程通常包括以下步骤:首先检查执行器是否已经关闭,如果已关闭则拒绝任务;然后检查是否有可用的工作线程;如果所有工作线程都在忙碌状态,则将任务放入队列等待执行;如果队列已满且线程数未达到最大值,则创建新的工作线程;如果线程数已达最大值,则根据拒绝策略处理任务。

#### 2.2.2 ExecutorService接口分析

ExecutorService是Executor的子接口,在任务执行的基础上增加了生命周期管理、任务提交和批量操作的能力。这些扩展使得ExecutorService成为一个功能完整的线程池管理接口。

```java
public interface ExecutorService extends Executor {
    void shutdown();
    List<Runnable> shutdownNow();
    boolean isShutdown();
    boolean isTerminated();
    boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;
    
    <T> Future<T> submit(Callable<T> task);
    <T> Future<T> submit(Runnable task, T result);
    Future<?> submit(Runnable task);
    
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException;
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException;
    
    <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException;
    <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;
}
```

**生命周期管理方法详解:**

shutdown方法启动有序关闭,已提交的任务会继续执行,但不再接受新任务。这个方法不会阻塞,调用后会立即返回。如果线程池已经关闭,则调用此方法没有额外效果。

shutdownNow方法尝试立即停止所有正在执行的任务,取消等待执行的任务,并返回等待执行的任务列表。方法的命名中的"Now"表明它试图立即停止,而非优雅关闭。

isShutdown方法简单判断线程池是否已关闭。这个方法返回true只表示shutdown方法已被调用,不表示所有任务都已完成。

isTerminated方法判断线程池是否已完全终止。只有在调用shutdown或shutdownNow后,且所有任务都已完成的情况下,此方法才返回true。

awaitTermination方法会阻塞调用线程,直到线程池终止或超时。如果线程池在超时前终止,则返回true;否则返回false。此方法在等待过程中如果被中断,会抛出InterruptedException。

**任务提交方法详解:**

submit方法支持三种形式的提交:提交Callable任务并获取Future结果,提交Runnable任务并返回固定结果,以及提交Runnable任务并返回null结果。submit方法是对execute方法的重要扩展,它允许调用者获取任务的执行结果或取消任务。

invokeAll方法提交一组任务,并阻塞等待所有任务完成。此方法返回包含每个任务Future的列表,所有Future的isDone方法都返回true。注意,完成的任务可能是正常完成,也可能是抛出异常完成。

invokeAny方法提交一组任务,并返回第一个成功完成的任务结果。调用此方法会取消其他未完成的任务。如果没有任何任务成功完成,则抛出ExecutionException。

#### 2.2.3 AbstractExecutorService抽象类

AbstractExecutorService提供了ExecutorService接口的骨架实现,简化了具体线程池实现的开发。这个抽象类实现了submit、invokeAll和invokeAny等通用逻辑,子类只需专注于核心的执行逻辑。

```java
public abstract class AbstractExecutorService implements ExecutorService {
    
    protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
        return new FutureTask<T>(callable);
    }
    
    protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
        return new FutureTask<T>(runnable, value);
    }
    
    public <T> Future<T> submit(Callable<T> task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }
    
    public <T> Future<T> submit(Runnable task, T result) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task, result);
        execute(ftask);
        return ftask;
    }
    
    public Future<?> submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task, null);
        execute(ftask);
        return ftask;
    }
    
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {
        if (tasks == null) throw new NullPointerException();
        List<Future<T>> futures = new ArrayList<Future<T>>(tasks.size());
        boolean done = false;
        try {
            for (Callable<T> t : tasks) {
                RunnableFuture<T> f = newTaskFor(t);
                futures.add(f);
                execute(f);
            }
            for (Future<T> f : futures) {
                if (!f.isDone()) {
                    f.get();
                }
            }
            done = true;
            return futures;
        } finally {
            if (!done) {
                for (Future<T> f : futures) {
                    f.cancel(true);
                }
            }
        }
    }
    
    // invokeAny方法的实现类似,此处省略
}
```

AbstractExecutorService的设计体现了模板方法模式。newTaskFor方法是protected的,允许子类重写以定制FutureTask的创建逻辑。submit方法通过调用newTaskFor创建任务,然后调用execute执行,最后返回Future给调用者。

invokeAll方法的实现展示了资源管理的最佳实践。在finally块中,如果不是所有任务都完成,会取消所有已提交的任务,确保不会造成资源泄漏。

### 2.3 ThreadPoolExecutor深度解析

#### 2.3.1 核心状态管理

ThreadPoolExecutor使用一个AtomicInteger类型的变量ctl来同时管理线程池的运行状态和工作线程数量。这种巧妙的设计将两个概念打包在一个AtomicInteger中,既保证了操作的原子性,又节省了内存空间。

```java
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
private static final int COUNT_BITS = Integer.SIZE - 3; // 29
private static final int CAPACITY   = (1 << COUNT_BITS) - 1; // 536870911

// 线程池状态定义
private static final int RUNNING    = -1 << COUNT_BITS; // 11100000...
private static final int SHUTDOWN   =  0 << COUNT_BITS; // 00000000...
private static final int STOP       =  1 << COUNT_BITS; // 00100000...
private static final int TIDYING    =  2 << COUNT_BITS; // 01000000...
private static final int TERMINATED =  3 << COUNT_BITS; // 01100000...
```

**状态转换图:**

```
                    shutdown()
     RUNNING ----------------> SHUTDOWN
        |                        |
        |                        | stop()
        |                        v
        |                     STOP ----------------> TIDYING
        |                        |                        |
        |                        |                        | 所有任务Terminated
        |                        |                        v
        |                        |                   TERMINATED
        |                        |
        |shutdownNow()          |
        +-----------------------+
```

**状态说明:**

RUNNING状态是线程池的初始状态,在这个状态下,线程池可以接受新任务并处理队列中的任务。SHUTDOWN状态表示线程池正在关闭过程中,这个状态下不会再接受新任务,但会继续处理队列中已有的任务。STOP状态表示线程池正在停止,这个状态下不会接受新任务,也不会处理队列中的任务,同时会尝试中断正在执行的任务。TIDYING状态表示所有任务都已终止,工作线程数为0,即将调用terminated钩子方法。TERMINATED状态表示terminated方法已执行完毕,线程池完全终止。

**ctl位运算操作:**

```java
private static int runStateOf(int c) { return c & ~CAPACITY; }
private static int workerCountOf(int c) { return c & CAPACITY; }
private static int ctlOf(int rs, int wc) { return rs | wc; }
```

这些方法使用位运算从ctl中提取运行状态和工作线程数量。runStateOf通过与CAPACITY的按位取反进行与操作,得到高3位的状态码。workerCountOf直接与CAPACITY进行与操作,得到低29位的线程数量。ctlOf将状态码和工作线程数量合并成完整的ctl值。

**状态判断方法:**

```java
private static boolean isRunning(int c) {
    return c < SHUTDOWN;
}
```

isRunning方法通过判断ctl值是否小于SHUTDOWN状态来判断线程池是否处于运行状态。由于RUNNING状态是-1,SHUTDOWN状态是0,任何正数状态都大于SHUTDOWN。

#### 2.3.2 线程池参数详解

ThreadPoolExecutor的构造方法定义了线程池的所有配置参数,理解这些参数对于合理使用线程池至关重要。

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.workQueue = workQueue;
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```

**corePoolSize(核心线程数):** 核心线程数定义了线程池即使在空闲时也会保持的最小线程数量。当任务提交时,如果当前工作线程数小于corePoolSize,即使有空闲线程,也会创建新的核心线程来执行任务。核心线程默认会一直存活,不会因为空闲而被终止。

**maximumPoolSize(最大线程数):** 最大线程数定义了线程池能够容纳的最大线程数量。当队列已满且工作线程数小于最大线程数时,线程池会创建新的非核心线程来执行任务。非核心线程在空闲超过keepAliveTime后会终止。

**keepAliveTime(空闲线程存活时间):** 这个参数定义了非核心线程在空闲状态下的最大存活时间。只有当工作线程数大于corePoolSize时,超过corePoolSize的部分才被视为非核心线程,其空闲超时后会被终止。

**workQueue(工作队列):** 工作队列用于存放等待执行的任务。常用的队列包括:LinkedBlockingQueue(无界队列)、ArrayBlockingQueue(有界队列)、SynchronousQueue(同步队列)、PriorityBlockingQueue(优先级队列)。

**threadFactory(线程工厂):** 线程工厂负责创建新的工作线程。通过自定义线程工厂,可以设置线程的名称、优先级、守护状态等属性,便于问题排查和监控。

**handler(拒绝策略):** 当线程池无法接受新任务时(队列已满且线程数已达最大值),会调用拒绝策略处理被拒绝的任务。Java提供了四种内置的拒绝策略。

#### 2.3.3 任务执行流程

ThreadPoolExecutor的任务执行流程是其核心逻辑,这个流程体现了线程池如何处理任务的提交和执行。

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    
    int c = ctl.get();
    if (workerCountOf(c) < corePoolSize) {
        // 情况1: 工作线程数 < 核心线程数,创建新的核心线程
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    
    // 情况2: 工作线程数 >= 核心线程数,尝试将任务加入队列
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        if (!isRunning(recheck) && remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    // 情况3: 队列已满,尝试创建非核心线程
    else if (!addWorker(command, false))
        reject(command);
}
```

**执行流程详解:**

当execute方法被调用时,首先会检查工作线程数量。如果当前工作线程数小于corePoolSize,会尝试创建新的核心线程来执行任务。创建线程成功则直接返回,失败则重新获取ctl值。

如果工作线程数已达到核心线程数,会尝试将任务加入工作队列。加入队列成功后,需要再次检查线程池状态,因为状态可能在加入队列过程中发生变化。如果线程池不再运行,则移除刚加入的任务并拒绝执行。如果线程池仍在运行但没有工作线程,则创建一个空的非核心线程来处理队列中的任务。

如果队列已满无法加入,则尝试创建非核心线程来执行任务。如果创建失败(线程数已达最大值),则调用拒绝策略处理被拒绝的任务。

**addWorker方法详解:**

```java
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);
        
        // 检查线程池状态
        if (rs >= SHUTDOWN &&
            !(rs == SHUTDOWN && firstTask == null && !workQueue.isEmpty()))
            return false;
        
        for (;;) {
            int wc = workerCountOf(c);
            // 检查线程数量限制
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            // CAS增加工作线程数
            if (compareAndIncrementWorkerCount(c))
                break retry;
            c = ctl.get();
            if (runStateOf(c) != rs)
                continue retry;
        }
    }
    
    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        w = new Worker(firstTask);
        Thread t = w.thread;
        if (t != null) {
            // 使用ReentrantLock保护workers集合
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                int rs = runStateOf(ctl.get());
                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive())
                        throw new IllegalThreadStateException();
                    workers.add(w);
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        if (!workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```

addWorker方法是线程池创建新工作线程的核心方法。它首先通过双重循环的CAS操作来原子地增加工作线程计数,然后创建Worker对象并启动线程。Worker是ThreadPoolExecutor的内部类,封装了工作线程的执行逻辑。

#### 2.3.4 Worker内部类详解

Worker类是ThreadPoolExecutor的核心内部类,它实现了Runnable接口,封装了工作线程的执行逻辑。

```java
private final class Worker extends AbstractQueuedSynchronizer implements Runnable {
    final Thread thread;
    Runnable firstTask;
    volatile long completedTasks;
    
    Worker(Runnable firstTask) {
        this.firstTask = firstTask;
        this.thread = ThreadFactory.threadPoolNumber.getAndIncrement();
        // 将thread字段设置为当前Worker,用于线程中断检查
        thread.setDaemon(true); 
    }
    
    public void run() {
        runWorker(this);
    }
    
    // 锁相关方法,实现简单不可重入锁
    protected boolean isHeldExclusively() {
        return getState() != 0;
    }
    
    protected boolean tryAcquire(int unused) {
        if (compareAndSetState(0, 1)) {
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        }
        return false;
    }
    
    protected boolean tryRelease(int unused) {
        setExclusiveOwnerThread(null);
        setState(0);
        return true;
    }
}
```

Worker类继承AbstractQueuedSynchronizer来实现简单的互斥锁。这个锁的作用是在线程执行任务期间保持线程的中断状态,避免在执行关键代码时被中断。

**runWorker方法详解:**

```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // 允许中断
    
    boolean completedAbruptly = true;
    try {
        // 循环获取并执行任务
        while (task != null || (task = getTask()) != null) {
            w.lock();
            try {
                // 任务执行前钩子
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x;
                    throw x;
                } catch (Error x) {
                    thrown = x;
                    throw x;
                } catch (Throwable x) {
                    thrown = x;
                    throw new Error(x);
                } finally {
                    // 任务执行后钩子
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        // 处理线程退出
        processWorkerExit(w, completedAbruptly);
    }
}
```

runWorker方法是工作线程的核心执行逻辑。它首先释放锁以允许中断,然后进入主循环不断获取并执行任务。在任务执行前后分别调用beforeExecute和afterExecute钩子方法,允许子类扩展处理逻辑。

**getTask方法详解:**

```java
private Runnable getTask() {
    boolean timedOut = false;
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);
        
        // 检查线程池状态
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }
        
        boolean timed;
        for (;;) {
            int wc = workerCountOf(c);
            // 判断是否需要超时控制
            timed = wc > corePoolSize || allowCoreThreadTimeOut;
            if (wc <= maximumPoolSize && !(timed && timedOut))
                break;
            if (compareAndDecrementWorkerCount(c))
                return null;
            c = ctl.get();
        }
        
        try {
            // 从队列获取任务
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
```

getTask方法负责从工作队列获取待执行的任务。它通过判断线程数量是否超过corePoolSize或是否允许核心线程超时,来决定使用poll还是take方法从队列获取任务。如果队列为空且线程需要超时,则poll会返回null,触发线程退出逻辑。

#### 2.3.5 线程池关闭与资源清理

线程池的关闭过程需要优雅地处理正在执行的任务和等待队列中的任务,确保不会丢失任务或造成资源泄漏。

```java
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        advanceRunState(SHUTDOWN);
        // 中断空闲线程
        interruptIdleWorkers();
        // 调用shutdown钩子
        onShutdown();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
}

public List<Runnable> shutdownNow() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        advanceRunState(STOP);
        // 中断所有线程
        interruptWorkers();
        // 清除队列中的任务
        List<Runnable> tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
    return tasks;
}
```

shutdown方法将线程池状态设置为SHUTDOWN,然后中断所有空闲的工作线程。中断空闲线程使用interruptIdleWorkers方法,该方法尝试获取Worker的锁,如果获取成功则中断线程,表示该线程正在等待任务,可以被安全中断。

shutdownNow方法将线程池状态设置为STOP,然后尝试中断所有工作线程,无论是否空闲。与shutdown不同,STOP状态会丢弃等待队列中的任务,并返回这些任务列表供调用者处理。

**tryTerminate方法:**

```java
final void tryTerminate() {
    for (;;) {
        int c = ctl.get();
        if (isRunning(c) ||
            runStateOf(c) == TIDYING ||
            runStateOf(c) == TERMINATED ||
            (runStateOf(c) == SHUTDOWN && !workQueue.isEmpty()))
            return;
        
        if (workerCountOf(c) != 0) {
            interruptIdleWorkers(ONLY_ONE);
            return;
        }
        
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                try {
                    terminated();
                } finally {
                    ctl.set(ctlOf(TERMINATED, 0));
                    termination.signalAll();
                }
                return;
            }
        } finally {
            mainLock.unlock();
        }
    }
}
```

tryTerminated方法是线程池终止的核心逻辑。当线程池状态为SHUTDOWN且队列为空,或者状态为STOP时,会尝试将状态推进到TERMINATED。在推进过程中,需要确保所有工作线程都已退出,然后调用terminated钩子方法通知子类线程池已终止。

### 2.4 Executors工厂类详解

Executors提供了多种工厂方法创建预配置的线程池,这些方法封装了ThreadPoolExecutor的配置细节,简化了线程池的创建过程。

#### 2.4.1 newFixedThreadPool

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```

固定大小线程池的核心线程数和最大线程数相同,使用无界队列。这意味着线程池永远不会创建非核心线程,队列会无限增长。这种配置适用于负载相对固定、不需要处理突发任务的场景。

**特点分析:**

第一,核心线程数等于最大线程数,意味着所有线程都是核心线程,不会被终止。第二,使用LinkedBlockingQueue作为工作队列,这是一个无界队列,理论上可以无限存储等待任务。第三,keepAliveTime设置为0,表示非核心线程会立即终止(但实际上不会有非核心线程)。

**适用场景:**

固定大小线程池适用于需要严格控制并发线程数量的场景,例如处理固定数量的连接或请求。由于使用无界队列,需要注意任务积压可能导致内存溢出的问题。

#### 2.4.2 newCachedThreadPool

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
```

缓存线程池的核心线程数为0,最大线程数为Integer.MAX_VALUE,使用SynchronousQueue作为工作队列。这意味着线程池会根据任务数量动态调整线程数量,空闲线程超过60秒后会被终止。

**特点分析:**

第一,核心线程数为0,意味着所有线程都是非核心线程。第二,使用SynchronousQueue,这是一个不存储元素的队列,每个插入操作必须等待一个删除操作。第三,最大线程数为Integer.MAX_VALUE,理论上可以创建无限多的线程。

**适用场景:**

缓存线程池适用于处理大量短期异步任务的场景。线程会在任务到来时创建,空闲60秒后自动回收,非常适合执行时间短、数量多的任务。

**风险提示:**

使用缓存线程池时需要注意,如果没有任务量限制,可能导致创建过多线程,耗尽系统资源。SynchronousQueue的公平策略也会影响任务分配的公平性。

#### 2.4.3 newSingleThreadExecutor

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```

单线程线程池内部只有一个工作线程,所有任务按照提交顺序执行。这种配置确保了任务的串行执行,避免了并发问题。

**FinalizableDelegatedExecutorService:**

```java
private static class FinalizableDelegatedExecutorService
    extends DelegatedExecutorService {
    FinalizableDelegatedExecutorService(ExecutorService executor) {
        super(executor);
    }
    protected void finalize() {
        super.shutdown();
    }
}
```

FinalizableDelegatedExecutorService是DelegatedExecutorService的子类,它在finalize方法中调用shutdown,确保线程池在垃圾回收时能够被正确关闭。

**适用场景:**

单线程线程池适用于需要保证任务顺序执行的场景,例如日志记录、顺序处理等。

#### 2.4.4 newScheduledThreadPool

```java
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolTime);
}
```

调度线程池支持定时任务和周期任务的执行。它继承自ThreadPoolExecutor,在其基础上增加了调度功能。

**ScheduledThreadPoolExecutor的构造方法:**

```java
public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue());
}
```

调度线程池使用DelayedWorkQueue作为工作队列,这是一个按照延迟时间排序的优先级队列。

**调度方法:**

```java
public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit);
public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit);
public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit);
public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit);
```

schedule方法用于执行一次性的延迟任务。scheduleAtFixedRate方法用于执行固定频率的周期任务,任务之间的间隔从任务开始时计算。scheduleWithFixedDelay方法用于执行固定延迟的周期任务,任务之间的间隔从任务结束后计算。

**scheduleAtFixedRate与scheduleWithFixedDelay的区别:**

scheduleAtFixedRate的周期是从任务开始时间计算的,如果任务执行时间超过周期时间,下一次任务会立即开始(不会等待)。scheduleWithFixedDelay的延迟是从任务结束后计算的,下一次任务会等待指定的延迟时间后才开始。

### 2.5 ForkJoinPool深度解析

#### 2.5.1 工作窃取算法概述

ForkJoinPool是一种特殊的线程池,专为分治任务设计。它采用工作窃取(Work-Stealing)算法,允许空闲的工作线程从其他线程的任务队列中"窃取"任务来执行,实现了高效的负载均衡。

**工作窃取算法的特点:**

第一,**双端队列设计**:每个工作线程维护一个双端队列,新任务放入队列头部,执行时从队列头部获取任务。第二,**窃取从尾部开始**:当线程空闲时,从其他线程队列的尾部窃取任务,减少与拥有线程的竞争。第三,**减少锁竞争**:由于窃取操作只访问队列尾部,不会与拥有线程的头部操作产生竞争。

**工作窃取示意图:**

```
工作线程1队列: [任务A] -> [任务B] -> [任务C]  (头部)
                ↑添加    ↑执行

工作线程2队列: [任务X] -> [任务Y] -> [任务Z]
                ↑窃取 ←窃取位置(尾部)
```

#### 2.5.2 ForkJoinPool核心实现

```java
public class ForkJoinPool extends AbstractExecutorService {
    // 控制状态,打包了活动计数、总计数、栈状态和索引
    volatile long ctl;
    // 运行状态
    volatile int runState;
    // 配置信息(并行度、模式)
    final int config;
    // 工作队列数组
    volatile WorkQueue[] workQueues;
    // 工作线程工厂
    final ForkJoinWorkerThreadFactory factory;
    // 未捕获异常处理器
    final UncaughtExceptionHandler ueh;
    // 工作线程名称前缀
    final String workerNamePrefix;
    // 窃取计数器
    volatile AtomicLong stealCounter;
}
```

**ctl字段的位布局:**

ctl是一个64位的原子变量,打包了4个16位的子字段:

- **AC (Active Count)**: 活动工作线程数减去目标并行度
- **TC (Total Count)**: 总工作线程数减去目标并行度
- **SS (Stack State)**: 顶部等待线程的版本计数和状态
- **ID (Pool Index)**: Treiber栈顶的池索引

```java
private static final int AC_SHIFT = 48;
private static final long AC_UNIT = 0x0001L << AC_SHIFT;
private static final long AC_MASK = 0xffffL << AC_SHIFT;

private static final int TC_SHIFT = 32;
private static final long TC_UNIT = 0x0001L << TC_SHIFT;
private static final long TC_MASK = 0xffffL << TC_SHIFT;
```

**工作队列WorkQueue:**

```java
static final class WorkQueue {
    volatile int scanState;    // 版本化状态,<0:非活动;奇数:扫描中
    int stackPred;             // 栈前驱
    int nsteals;               // 窃取计数
    int config;                // 池索引和模式
    volatile int qlock;        // 锁状态
    volatile int base;         // 下一个poll的索引
    int top;                   // 下一个push的索引
    ForkJoinTask<?>[] array;   // 任务数组
    final ForkJoinPool pool;   // 所属池
    final ForkJoinWorkerThread owner; // 拥有者线程
}
```

WorkQueue是ForkJoinPool的核心数据结构,采用双端队列设计。base指针指向队列的底部,用于窃取操作;top指针指向队列的顶部,用于本地线程的push和pop操作。

**push操作(本地线程添加任务):**

```java
final void push(ForkJoinTask<?> task) {
    ForkJoinTask<?>[] a; ForkJoinPool p;
    int b = base, s = top, n;
    if ((a = array) != null) {
        int m = a.length - 1;
        U.putOrderedObject(a, ((m & s) << ASHIFT) + ABASE, task);
        U.putOrderedInt(this, QTOP, s + 1);
        if ((n = s - b) <= 1) {
            if ((p = pool) != null)
                p.signalWork(p.workQueues, this);
        }
        else if (n >= m)
            growArray();
    }
}
```

push操作将任务放入队列头部,并更新top指针。使用putOrderedInt和putOrderedObject保证有序性和可见性。如果队列接近满载,则调用signalWork通知工作线程有新任务。

**poll操作(窃取任务):**

```java
final ForkJoinTask<?> poll() {
    ForkJoinTask<?>[] a; int b; ForkJoinTask<?> t;
    while ((b = base) - top < 0 && (a = array) != null) {
        int j = (((a.length - 1) & b) << ASHIFT) + ABASE;
        t = (ForkJoinTask<?>)U.getObjectVolatile(a, j);
        if (base == b) {
            if (t != null) {
                if (U.compareAndSwapObject(a, j, t, null)) {
                    base = b + 1;
                    return t;
                }
            }
            else if (b + 1 == top)
                break;
        }
    }
    return null;
}
```

poll操作从队列底部窃取任务。由于窃取操作访问的是base端,而本地线程访问的是top端,这样可以减少竞争。如果CAS失败,说明有竞争,需要重试。

**pop操作(本地线程获取任务):**

```java
final ForkJoinTask<?> pop() {
    ForkJoinTask<?>[] a; ForkJoinTask<?> t; int m;
    if ((a = array) != null && (m = a.length - 1) >= 0) {
        for (int s; (s = top - 1) - base >= 0;) {
            long j = ((m & s) << ASHIFT) + ABASE;
            if ((t = (ForkJoinTask<?>)U.getObject(a, j)) == null)
                break;
            if (U.compareAndSwapObject(a, j, t, null)) {
                U.putOrderedInt(this, QTOP, s);
                return t;
            }
        }
    }
    return null;
}
```

pop操作从队列头部获取本地线程的任务,采用LIFO顺序。这种设计利用了缓存局部性,提高了执行效率。

#### 2.5.3 ForkJoinTask详解

ForkJoinTask是ForkJoinPool中任务的基础抽象类,它是Future接口的实现,支持任务的分解(fork)和合并(join)。

```java
public abstract class ForkJoinTask<V> implements Future, Serializable {
    // 任务状态
    private volatile int status;
    // 结果值
    private V result;
    // 异常
    private Throwable ex;
    
    protected abstract boolean exec();
    
    public final V join() {
        int s;
        if ((s = doJoin()) <= 0)
            return null;
        throwException(s);
        return getRawResult();
    }
    
    public final void fork() {
        Thread t;
        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)
            ((ForkJoinWorkerThread)t).workQueue.push(this);
        else
            ForkJoinPool.common.externalPush(this);
    }
}
```

**RecursiveAction与RecursiveTask:**

```java
public abstract class RecursiveAction extends ForkJoinAction<Void> {
    protected abstract void compute();
}

public abstract class RecursiveTask<V> extends ForkJoinTask<V> {
    private transient V result;
    
    protected abstract V compute();
    
    public final V get() {
        int s;
        if ((s = doJoin()) != NORMAL)
            throwException(s);
        return result;
    }
    
    public final boolean exec() {
        result = compute();
        return true;
    }
}
```

RecursiveAction用于不需要返回结果的分治任务。RecursiveTask用于需要返回结果的分治任务。它们都定义了抽象的compute方法,子类需要实现任务的分解逻辑。

**分治任务示例:**

```java
public class SumTask extends RecursiveTask<Long> {
    private final long[] array;
    private final int start;
    private final int end;
    private static final int THRESHOLD = 1000;
    
    public SumTask(long[] array, int start, int end) {
        this.array = array;
        this.start = start;
        this.end = end;
    }
    
    @Override
    protected Long compute() {
        if (end - start <= THRESHOLD) {
            long sum = 0;
            for (int i = start; i < end; i++) {
                sum += array[i];
            }
            return sum;
        }
        
        int mid = (start + end) / 2;
        SumTask leftTask = new SumTask(array, start, mid);
        SumTask rightTask = new SumTask(array, mid, end);
        
        leftTask.fork();
        rightTask.fork();
        
        return leftTask.join() + rightTask.join();
    }
}
```

这个示例展示了如何使用ForkJoinTask实现分治计算。任务首先检查是否需要分解,如果子任务足够小则直接计算,否则分解为两个子任务并行执行。

### 2.6 线程池监控与调优

#### 2.6.1 线程池监控指标

ThreadPoolExecutor提供了多个方法用于监控线程池的状态:

```java
// 获取活动线程数(正在执行任务的线程)
public int getActiveCount();

// 获取任务队列中的任务数
public int getQueue().size();

// 获取已完成任务总数
public long getCompletedTaskCount();

// 获取任务队列
public BlockingQueue<Runnable> getQueue();

// 获取配置的最大线程数
public int getMaximumPoolSize();

// 获取核心线程数
public int getCorePoolSize();

// 获取线程池当前状态
public int getPoolSize();

// 获取最大曾达到的线程数
public int getLargestPoolSize();
```

这些指标对于监控线程池的健康状态和性能调优非常重要。通过定期收集这些指标,可以了解线程池的负载情况,发现潜在的问题。

#### 2.6.2 线程池调优策略

**根据任务特性选择合适的队列:**

CPU密集型任务应该使用较小的线程池,避免线程切换开销。IO密集型任务可以使用较大的线程池,因为线程大部分时间在等待IO完成。混合型任务需要根据实际情况调整。

**调整线程池参数:**

```java
// CPU密集型配置
int corePoolSize = Runtime.getRuntime().availableProcessors() + 1;
int maximumPoolSize = corePoolSize;
BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<>();

// IO密集型配置
int corePoolSize = Runtime.getRuntime().availableProcessors() * 2;
int maximumPoolSize = corePoolSize * 2;
BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<>();
```

**使用有界队列防止资源耗尽:**

```java
// 有界队列配置
int queueCapacity = 100;
BlockingQueue<Runnable> workQueue = new ArrayBlockingQueue<>(queueCapacity);

ThreadPoolExecutor executor = new ThreadPoolExecutor(
    corePoolSize,
    maximumPoolSize,
    keepAliveTime,
    TimeUnit.SECONDS,
    workQueue,
    new ThreadFactory() { ... },
    new CallerRunsPolicy() // 使用调用者执行策略
);
```

使用有界队列可以防止任务无限积压导致内存溢出。同时,需要配置合理的拒绝策略来处理队列满的情况。

#### 2.6.3 线程池异常处理

线程池默认会吞掉任务执行中的异常,需要在任务提交时进行异常处理:

```java
// 使用Future捕获异常
Future<?> future = executor.submit(() -> {
    throw new RuntimeException("Task failed");
});

try {
    future.get();
} catch (ExecutionException e) {
    Throwable cause = e.getCause();
    // 处理异常
}

// 使用UncaughtExceptionHandler处理未捕获异常
ThreadFactory factory = runnable -> {
    Thread thread = new Thread(runnable);
    thread.setUncaughtExceptionHandler((t, e) -> {
        System.err.println("Uncaught exception in thread " + t.getName());
        e.printStackTrace();
    });
    return thread;
};
```

### 2.7 小结

线程池是Java并发编程中最重要、最常用的组件之一。通过深入理解ThreadPoolExecutor的源码实现,我们可以:

第一,**合理配置线程池**:根据任务的特性选择合适的线程数、队列和拒绝策略,避免资源浪费或资源耗尽。

第二,**理解任务执行流程**:了解任务从提交到执行的完整流程,以及各个阶段的处理逻辑,有助于排查问题和优化性能。

第三,**掌握ForkJoinPool的工作窃取算法**:理解ForkJoinPool的双端队列设计和窃取机制,对于编写高效的并行算法至关重要。

第四,**进行有效的监控和调优**:利用线程池提供的监控方法和调优策略,持续优化系统性能。
