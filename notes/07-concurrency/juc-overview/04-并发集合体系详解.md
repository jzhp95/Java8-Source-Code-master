# Java并发编程(JUC)体系源码深度解析——并发集合体系详解

## 四、并发集合体系详解

### 4.1 并发集合概述

#### 4.1.1 为什么需要并发集合

在多线程环境中,普通的集合类（如ArrayList、HashMap）不是线程安全的。如果多个线程同时访问和修改同一个集合,会导致数据不一致、ConcurrentModificationException异常,甚至更严重的运行时错误。虽然可以使用Collections.synchronizedList等包装方法将普通集合转换为线程安全的集合,但这种方式的性能开销很大,因为所有操作都需要获取锁,无法实现真正的并发访问。

JUC提供了多种并发集合,它们针对高并发场景进行了优化,能够安全、高效地被多个线程同时访问。这些并发集合采用不同的并发策略,包括锁分离、乐观并发控制、无锁算法等,以最大化并发性能。

#### 4.1.2 并发集合分类

JUC的并发集合可以分为以下几类：

**ConcurrentHashMap**: 并发版本的HashMap,提供高效的键值存储和检索。支持完全并发的读取和可调整并发的写入。

**ConcurrentSkipListMap/Set**: 基于跳表实现的有序并发Map/Set。提供O(log n)的查找、插入和删除操作,并发安全。

**CopyOnWriteArrayList/Set**: 写时复制数组列表。读取操作完全无锁,写入操作会复制整个数组。适用于读多写少的场景。

**BlockingQueue**: 阻塞队列接口,实现了生产者-消费者模式。包括ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、DelayQueue、SynchronousQueue、LinkedTransferQueue等。

**ConcurrentLinkedQueue/Deque**: 基于CAS实现的无界并发队列。支持高效的入队和出队操作。

#### 4.1.3 并发集合的设计原则

**弱一致性**: 并发集合通常提供"弱一致性"保证。这意味着在遍历集合时,可以看到其他线程对集合的部分修改,但不一定是全部。这种设计避免了遍历过程中的加锁,大大提高了并发性能。

**CAS操作**: 尽可能使用CAS（Compare-And-Swap）操作代替锁,以实现无锁算法。CAS操作是原子的,不会阻塞线程,减少了上下文切换的开销。

**锁分离**: 对于需要修改的操作,尽可能只锁定必要的部分,而不是整个集合。例如,ConcurrentHashMap使用分段锁,每个桶独立加锁。

**volatile使用**: 使用volatile关键字保证共享变量的可见性,避免线程间的数据不一致。

### 4.2 ConcurrentHashMap深度解析

#### 4.2.1 ConcurrentHashMap概述

ConcurrentHashMap是Java中最常用的高性能并发Map实现。它是HashMap的线程安全版本,提供了比Hashtable更好的并发性能。ConcurrentHashMap的核心设计思想是"锁分离"——它将整个Map分成多个段（Segment）,每个段维护一个独立的哈希表,不同段的操作可以并行进行。

```java
public class ConcurrentHashMap<K,V> extends AbstractMap<K,V>
    implements ConcurrentMap<K,V>, Serializable {
    
    // 默认初始容量
    static final int DEFAULT_INITIAL_CAPACITY = 16;
    // 默认负载因子
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
    // 默认并发级别
    static final int DEFAULT_CONCURRENCY_LEVEL = 16;
    // 最大容量
    static final int MAXIMUM_CAPACITY = 1 << 30;
    // 每个Segment的最小容量
    static final int MIN_SEGMENT_TABLE_CAPACITY = 2;
    // Segment的最大数量
    static final int MAX_SEGMENTS = 1 << 16;
    // 用于无锁查找的掩码值
    static final int RESIZE_STAMP_BITS = 16;
    static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;
    static final int RESERVED = 0;
    // CPU数量
    static final int NCPU = Runtime.getRuntime().availableProcessors();
}
```

ConcurrentHashMap使用多个技术来提高并发性能：首先是分段锁技术,将Map分成多个Segment,每个Segment维护一个独立的哈希表；其次是使用CAS操作进行无锁的更新；最后是使用volatile保证可见性。

#### 4.2.2 JDK 7与JDK 8的实现差异

在JDK 7中,ConcurrentHashMap使用Segment和HashEntry的数组结构,每个Segment继承自ReentrantLock,提供互斥访问。

```java
// JDK 7的Segment结构
static final class Segment<K,V> extends ReentrantLock implements Serializable {
    transient volatile HashEntry<K,V>[] table;
    transient int count;
    transient int modCount;
    transient int threshold;
    final float loadFactor;
}
```

在JDK 8中,ConcurrentHashMap进行了重大重构,移除了Segment层,直接使用Node数组和CAS操作。新实现更加简洁高效,类似于HashMap的数组+链表+红黑树结构。

#### 4.2.3 JDK 8的Node数组结构

```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    volatile V val;
    volatile Node<K,V> next;
    
    Node(int hash, K key, V val, Node<K,V> next) {
        this.hash = hash;
        this.key = key;
        this.val = val;
        this.next = next;
    }
    
    public final K getKey() { return key; }
    public final V getValue() { return val; }
    public final int hashCode() { return key.hashCode() ^ val.hashCode(); }
    public final String toString() { return key + "=" + val; }
    
    // 不允许修改值
    public final V setValue(V value) {
        throw new UnsupportedOperationException();
    }
    
    public final boolean equals(Object o) {
        Map.Entry<?,?> e;
        return o instanceof Map.Entry &&
            (e = (Map.Entry<?,?>)o) != null &&
            (key == null ? e.getKey() == null : key.equals(e.getKey())) &&
            (value == null ? e.getValue() == null : value.equals(e.getValue()));
    }
    
    // 查找节点
    Node<K,V> find(int h, Object k) {
        Node<K,V> e = this;
        if (e != null) {
            do {
                if (e.hash == h &&
                    ((k = e.key) == k || (k != null && k.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
        return null;
    }
}
```

Node是ConcurrentHashMap的基本元素类型,类似于HashMap的Entry。key和value字段是final的,保证键值不可变；next字段是volatile的,保证链表遍历的可见性。setValue方法抛出UnsupportedOperationException,不允许直接修改值。

#### 4.2.4 核心属性与状态控制

```java
// 哈希表数组
transient volatile Node<K,V>[] table;

// 下一个要使用的表（用于扩容）
private transient volatile Node<K,V>[] nextTable;

// 基础计数,用于计算大小
private transient volatile long baseCount;

// 哈希表的初始化或扩容控制
private transient volatile int sizeCtl;

// 扩容时,每个线程处理的桶数量
private static final int RESIZE_BITS = 16;
private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_BITS;

// 转移任务
private transient volatile int transferIndex;

// 锁住表头用于初始化
private transient volatile int cellsBusy;

// 计数器单元数组
private transient volatile CounterCell[] counterCells;
```

这些属性都是volatile的,保证多线程间的可见性。sizeCtl是控制哈希表状态的关键变量：当sizeCtl < 0时,表示表正在初始化或扩容；当sizeCtl > 0时,表示表的初始化容量。

#### 4.2.5 核心put操作实现

```java
public V put(K key, V value) {
    return putVal(key, value, false);
}

final V putVal(K key, V value, boolean onlyIfAbsent) {
    if (key == null || value == null) throw new NullPointerException();
    int hash = spread(key.hashCode());
    int binCount = 0;
    for (Node<K,V>[] tab = table;;) {
        Node<K,V> f; int n, i, fh;
        // 表为空,初始化
        if (tab == null || (n = tab.length) == 0) {
            n = (tab = initTable()).length;
        }
        // 找到桶位置,桶为空
        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
            if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value, null)))
                break;
        }
        // 桶正在扩容,帮助扩容
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        // 桶已有节点,链表或红黑树处理
        else {
            V oldVal = null;
            synchronized (f) {
                if (tabAt(tab, i) == f) {
                    if (fh < 0) {
                        // 红黑树节点
                        binCount = 1;
                        for (Node<K,V> e = f;; ++binCount) {
                            K ek;
                            if (e.hash == hash &&
                                ((ek = e.key) == key ||
                                 (ek != null && key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            Node<K,V> pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node<K,V>(hash, key, value, null);
                                break;
                            }
                        }
                    }
                    else {
                        // 链表节点
                        binCount = 1;
                        for (Node<K,V> e = f;; ++binCount) {
                            K ek;
                            if (e.hash == hash &&
                                ((ek = e.key) == key ||
                                 (ek != null && key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            Node<K,V> pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node<K,V>(hash, key, value, null);
                                // 链表转红黑树检查
                                if (binCount >= TREEIFY_THRESHOLD - 1)
                                    treeifyBin(tab, i);
                                break;
                            }
                        }
                    }
                }
            }
            if (binCount != 0) {
                if (binCount >= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    addCount(1L, binCount);
    return null;
}
```

putVal方法是put操作的核心实现。它的执行流程如下：

1. 首先检查key和value不为null
2. 计算哈希值,使用spread函数进行扰动
3. 循环处理直到操作完成
4. 如果表为空,初始化表
5. 如果桶为空,使用CAS尝试创建新节点
6. 如果正在扩容(h == MOVED),帮助扩容
7. 如果桶有节点,使用synchronized锁定桶头,然后遍历链表或红黑树进行处理
8. 操作完成后调用addCount更新计数

**spread函数**对哈希码进行扰动,减少哈希冲突：

```java
static final int spread(int h) {
    return (h ^ (h >>> 16)) & HASH_BITS;
}
```

**tabAt、casTabAt、setTabAt**是操作数组元素的工具方法,使用Unsafe API保证可见性：

```java
@SuppressWarnings("unchecked")
static final <K,V> Node<K,V> tabAt(Node<K,V>[] tab, int i) {
    return (Node<K,V>)U.getObjectVolatile(tab, ((long)i << ASHIFT) + ABASE);
}

static final <K,V> boolean casTabAt(Node<K,V>[] tab, int i,
                                    Node<K,V> c, Node<K,V> v) {
    return U.compareAndSwapObject(tab, ((long)i << ASHIFT) + ABASE, c, v);
}

static final <K,V> void setTabAt(Node<K,V>[] tab, int i, Node<K,V> v) {
    U.putObjectVolatile(tab, ((long)i << ASHIFT) + ABASE, v);
}
```

#### 4.2.6 链表转红黑树

当链表长度超过阈值时,会转换为红黑树以提高查找效率：

```java
private final void treeifyBin(Node<K,V>[] tab, int index) {
    Node<K,V> bin = null;
    for (Node<K,V> f = tabAt(tab, index); f != null; f = f.next) {
        if (bin == null) {
            bin = f;
        } else {
            int n, fh;
            if ((n = bin.next) == null)
                bin.next = f;
            else {
                TreeNode<K,V> hd = null, tl = null;
                do {
                    TreeNode<K,V> p = new TreeNode<>(f.hash, f.key, f.val, null);
                    if ((p.prev = tl) == null)
                        hd = p;
                    else
                        tl.next = p;
                    tl = p;
                } while ((f = f.next) != null);
                if ((tl.next = bin) != null)
                    bin.prev = tl;
                bin = hd;
            }
        }
    }
    setTabAt(tab, index, bin);
    if (bin != null)
        bin.treeify(tab);
}
```

treeifyBin方法将链表转换为红黑树。首先收集链表节点创建TreeNode,然后调用treeify方法构建红黑树。

#### 4.2.7 扩容机制

ConcurrentHashMap支持在线扩容,当表中的元素数量超过阈值时,会触发扩容操作。扩容过程中,新表是旧表的两倍大小,元素会从旧表迁移到新表。

```java
private final void addCount(long x, int check) {
    CounterCell[] as; long s, c;
    // 更新计数器
    if ((as = counterCells) != null ||
        !U.compareAndSwapLong(this, BASECOUNT, s = baseCount, c = s + x)) {
        CounterCell a; long m; int v;
        boolean uncontended = true;
        if (as == null || (m = as.length - 1) < 0 ||
            (a = as[(m + 1) & ThreadLocalRandom.getProbe()]) == null ||
            !(uncontended =
                U.compareAndSwapLong(a, CELLVALUE, v = a.value, c = v + x))) {
            fullAddCount(x, uncontended);
            return;
        }
    }
    // 检查是否需要扩容
    if (check >= 0) {
        Node<K,V>[] tab, nt;
        int n, sc;
        while ((s = sumCount()) > (long)(sc = sizeCtl) &&
               (tab = table) != null &&
               (n = tab.length) < MAXIMUM_CAPACITY) {
            int rs = resizeStamp(n);
            if (sc < 0) {
                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                    transferIndex <= 0)
                    break;
                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                    transfer(tab, nt);
            }
            else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs << RESIZE_STAMP_SHIFT) + 2))
                transfer(tab, null);
        }
    }
}
```

addCount方法用于更新计数器并检查是否需要扩容。ConcurrentHashMap使用CounterCell数组来并行计算元素数量,避免了对baseCount的竞争。

#### 4.2.8 get操作实现

```java
public V get(Object key) {
    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
    int hash = spread(key.hashCode());
    // 计算桶位置并遍历链表/红黑树
    for (Node<K,V>[] tab = table;;) {
        if ((tab = table) != null && (n = tab.length) > 0 &&
            (e = tabAt(tab, (n - 1) & hash)) != null) {
            if ((eh = e.hash) == hash) {
                if ((ek = e.key) == key || (ek != null && key.equals(ek)))
                    return e.val;
            }
            else if (eh < 0)
                return e.find(hash, key);
            while ((e = e.next) != null) {
                if (e.hash == hash &&
                    ((ek = e.key) == key || (ek != null && key.equals(ek))))
                    return e.val;
            }
        }
    }
    return null;
}
```

get操作是无锁的,只需要读取volatile变量和遍历链表/红黑树即可。Java内存模型的happens-before规则保证了能读到其他线程对Node的修改。

### 4.3 CopyOnWriteArrayList详解

#### 4.3.1 写时复制列表概述

CopyOnWriteArrayList是ArrayList的线程安全变体。它通过复制底层数组的方式实现线程安全——每次修改操作（add、set、remove等）都会创建底层数组的新副本。这种设计使得读操作完全不需要加锁,可以并发执行。

```java
public class CopyOnWriteArrayList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable {
    
    private transient volatile Object[] array;
    
    final Object[] getArray() {
        return array;
    }
    
    final void setArray(Object[] a) {
        array = a;
    }
}
```

array是CopyOnWriteArrayList的核心,它被声明为volatile以保证可见性。所有修改操作都会创建新数组,然后更新array引用。

#### 4.3.2 核心操作实现

```java
public E get(int index) {
    return get(getArray(), index);
}

public boolean add(E e) {
    synchronized (lock) {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    }
}

public E set(int index, E element) {
    synchronized (lock) {
        Object[] elements = getArray();
        E oldValue = get(elements, index);
        if (oldValue != element) {
            int len = elements.length;
            Object[] newElements = Arrays.copyOf(elements, len);
            newElements[index] = element;
            setArray(newElements);
        } else {
            setArray(elements);
        }
        return oldValue;
    }
}

public boolean remove(Object o) {
    Object[] snapshot = getArray();
    int index = indexOf(o, snapshot, 0, snapshot.length);
    return (index < 0) ? false : remove(o, snapshot, index);
}
```

修改操作使用synchronized加锁,确保同一时刻只有一个线程能够修改列表。读取操作（get）不需要加锁,因为array是volatile的,读取的是最新的数组引用。

#### 4.3.3 迭代器特性

```java
public Iterator<E> iterator() {
    return new COWIterator<E>(getArray(), 0);
}

static final class COWIterator<E> implements ListIterator<E> {
    private final Object[] snapshot;
    private int cursor;
    
    COWIterator(Object[] array, int initialCursor) {
        this.snapshot = array;
        this.cursor = initialCursor;
    }
    
    public boolean hasNext() { return cursor < snapshot.length; }
    public boolean hasPrevious() { return cursor > 0; }
    public E next() { return (E) snapshot[cursor++]; }
    public E previous() { return (E) snapshot[--cursor]; }
    public int nextIndex() { return cursor; }
    public int previousIndex() { return cursor - 1; }
    
    public void remove() {
        throw new UnsupportedOperationException();
    }
    
    public void set(E e) {
        throw new UnsupportedOperationException();
    }
    
    public void add(E e) {
        throw new UnsupportedOperationException();
    }
}
```

CopyOnWriteArrayList的迭代器是"快照迭代器"。在创建迭代器时,它会保存当前数组的引用,之后的遍历都基于这个快照。这意味着迭代过程中对列表的修改不会影响迭代器,也不会抛出ConcurrentModificationException。

### 4.4 BlockingQueue详解

#### 4.4.1 阻塞队列概述

BlockingQueue是支持阻塞操作的队列接口。当队列满时,插入操作会阻塞；当队列空时,取出操作会阻塞。这使得BlockingQueue非常适合实现生产者-消费者模式。

```java
public interface BlockingQueue<E> extends Queue<E> {
    // 插入
    boolean add(E e);
    boolean offer(E e);
    void put(E e) throws InterruptedException;
    boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException;
    
    // 取出
    E take() throws InterruptedException;
    E poll(long timeout, TimeUnit unit) throws InterruptedException;
    
    // 检查
    int remainingCapacity();
    boolean contains(Object o);
    int drainTo(Collection<? super E> c);
    int drainTo(Collection<? super E> c, int maxElements);
}
```

#### 4.4.2 ArrayBlockingQueue

ArrayBlockingQueue是使用数组实现的有界阻塞队列。

```java
public class ArrayBlockingQueue<E> extends AbstractQueue<E>
    implements BlockingQueue<E>, Serializable {
    
    final Object[] items;
    int takeIndex;
    int putIndex;
    int count;
    
    final ReentrantLock lock = new ReentrantLock();
    private final Condition notEmpty = lock.newCondition();
    private final Condition notFull = lock.newCondition();
    
    public ArrayBlockingQueue(int capacity) {
        this(capacity, false);
    }
    
    public ArrayBlockingQueue(int capacity, boolean fair) {
        if (capacity <= 0) throw new IllegalArgumentException();
        this.items = new Object[capacity];
        this.lock = new ReentrantLock(fair);
        this.notEmpty = lock.newCondition();
        this.notFull = lock.newCondition();
    }
}
```

ArrayBlockingQueue使用一个ReentrantLock保护所有对队列的访问,并使用两个Condition（notEmpty和notFull）来实现阻塞和唤醒。

**put操作:**

```java
public void put(E e) throws InterruptedException {
    if (e == null) throw new NullPointerException();
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        while (count == items.length)
            notFull.await();
        enqueue(e);
    } finally {
        lock.unlock();
    }
}

private void enqueue(E x) {
    items[putIndex] = x;
    if (++putIndex == items.length) putIndex = 0;
    count++;
    notEmpty.signal();
}
```

put操作首先获取锁,然后在队列满时等待notFull条件。插入元素后,唤醒等待取元素的线程。

**take操作:**

```java
public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        while (count == 0)
            notEmpty.await();
        return dequeue();
    } finally {
        lock.unlock();
    }
}

private E dequeue() {
    @SuppressWarnings("unchecked")
    E x = (E) items[takeIndex];
    items[takeIndex] = null;
    if (++takeIndex == items.length) takeIndex = 0;
    count--;
    notFull.signal();
    return x;
}
```

take操作与put操作对称：在队列空时等待notEmpty条件,取出元素后唤醒等待插入的线程。

#### 4.4.3 LinkedBlockingQueue

LinkedBlockingQueue是使用链表实现的无界阻塞队列。默认情况下,容量为Integer.MAX_VALUE,可以看作是无界的。

```java
public class LinkedBlockingQueue<E> extends AbstractQueue<E>
    implements BlockingQueue<E>, Serializable {
    
    static class Node<E> {
        E item;
        Node<E> next;
        Node(E x) { item = x; }
    }
    
    private final int capacity;
    private final AtomicInteger count = new AtomicInteger(0);
    
    private transient Node<E> head;
    private transient Node<E> last;
    
    private final ReentrantLock takeLock = new ReentrantLock();
    private final Condition notEmpty = takeLock.newCondition();
    
    private final ReentrantLock putLock = new ReentrantLock();
    private final Condition notFull = putLock.newCondition();
}
```

LinkedBlockingQueue使用两把锁（takeLock和putLock）分别保护取操作和放操作,提高了并发性能。这与ArrayBlockingQueue的单锁设计不同。

#### 4.4.4 SynchronousQueue

SynchronousQueue是一种特殊的阻塞队列,它不存储元素。每个插入操作必须等待一个取出操作,反之亦然。

```java
public class SynchronousQueue<E> extends AbstractQueue<E>
    implements BlockingQueue<E>, Serializable {
    
    public SynchronousQueue() {
        this(false);
    }
    
    public SynchronousQueue(boolean fair) {
        fair = fair && Uses队列 > 0;
        transferer = fair ? new TransferQueue<E>() : new TransferStack<E>();
    }
}
```

SynchronousQueue有两种模式：公平模式（FIFO）和非公平模式（栈LIFO）。公平模式下,线程按先来先到的顺序匹配；非公平模式下,后到的线程可能先被匹配。

#### 4.4.5 PriorityBlockingQueue

PriorityBlockingQueue是基于堆实现的无界阻塞优先级队列。元素按自然顺序或提供的Comparator排序。

```java
public class PriorityBlockingQueue<E> extends AbstractQueue<E>
    implements BlockingQueue<E>, Serializable {
    
    private transient Object[] queue;
    private transient int size;
    private transient Comparator<? super E> comparator;
    
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition notEmpty = lock.newCondition();
    
    public E take() throws InterruptedException {
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (size == 0)
                notEmpty.await();
            return extractMax();
        } finally {
            lock.unlock();
        }
    }
}
```

PriorityBlockingQueue使用堆数据结构保证优先级,堆顶元素（最小或最大）总是最先被取出。

### 4.5 并发Set与Map

#### 4.5.1 CopyOnWriteArraySet

```java
public class CopyOnWriteArraySet<E> extends AbstractSet<E>
    implements Set<E>, java.io.Serializable {
    
    final CopyOnWriteArrayList<E> al;
    
    public CopyOnWriteArraySet() {
        al = new CopyOnWriteArrayList<E>();
    }
    
    public boolean add(E e) {
        return al.addIfAbsent(e);
    }
}
```

CopyOnWriteArraySet内部使用CopyOnWriteArrayList,利用addIfAbsent方法保证元素不重复。

#### 4.5.2 ConcurrentSkipListMap/Set

ConcurrentSkipListMap是跳表（Skip List）实现的有序并发Map。跳表是一种多层链表结构,可以实现O(log n)的查找、插入和删除操作。

```java
public class ConcurrentSkipListMap<K,V> extends AbstractMap<K,V>
    implements ConcurrentNavigableMap<K,V>, Serializable {
    
    // 跳表索引层
    private transient volatile HeadIndex<K,V> head;
    
    // 基准比较器
    final Comparator<? super K> comparator;
    
    // 随机数生成器
    private static final java.util.Random random =
        java.security.AccessController.doPrivileged(
            new java.security.PrivilegedAction<java.util.Random>() {
                public java.util.Random run() {
                    return new java.util.Random();
                }
            });
}
```

ConcurrentSkipListMap提供有序性保证,键按自然顺序或Comparator顺序排列。它支持并发的高效查找、插入和删除操作。

ConcurrentSkipListSet是ConcurrentSkipListMap的包装,提供Set接口。

### 4.6 并发集合使用最佳实践

#### 4.6.1 选择合适的并发集合

**选择ConcurrentHashMap的情况:** 需要高效的键值存储,读多写少,不需要排序。

**选择ConcurrentSkipListMap的情况:** 需要有序的键值存储,需要范围查询。

**选择CopyOnWriteArrayList的情况:** 读操作远多于写操作,列表较小,迭代频繁。

**选择BlockingQueue的情况:** 实现生产者-消费者模式,需要阻塞等待。

**选择ConcurrentLinkedQueue的情况:** 需要高性能的队列,不需要阻塞。

#### 4.6.2 避免常见错误

**错误1:在遍历时修改集合**

```java
// 错误示例
for (Object item : concurrentMap.keySet()) {
    if (shouldRemove(item))
        concurrentMap.remove(item); // 可能抛出ConcurrentModificationException
}

// 正确示例1:使用迭代器的remove方法(如果支持)
for (Iterator<Object> it = concurrentMap.keySet().iterator(); it.hasNext();) {
    Object key = it.next();
    if (shouldRemove(key))
        it.remove();
}

// 正确示例2:使用removeIf方法
concurrentMap.keySet().removeIf(this::shouldRemove);
```

**错误2:过度依赖size()**

```java
// 错误示例
while (queue.size() > 0) {
    process(queue.poll()); // size()可能已过时
}

// 正确示例
while ((item = queue.poll()) != null) {
    process(item);
}
```

#### 4.6.3 性能优化建议

**使用批量操作:** 大多数并发集合提供批量操作方法,这些方法通常比单个操作更高效。

```java
// 低效
for (Object item : collection) {
    map.put(key(item), value(item));
}

// 高效
map.putAll(computeBatchMap());
```

**使用适当的数据结构:** 根据访问模式选择合适的并发集合。读多写少用CopyOnWriteArrayList,需要排序用ConcurrentSkipListMap,生产者-消费者用BlockingQueue。

### 4.7 小结

并发集合是JUC的重要组成部分,为多线程环境下的数据共享提供了高效、安全的工具。理解这些并发集合的实现原理和使用场景,对于编写高质量的并发程序至关重要。

**核心要点总结：**

第一,**ConcurrentHashMap**采用锁分离和CAS操作实现高并发性能,JDK 8版本移除了Segment层,使用Node数组+链表+红黑树结构。

第二,**CopyOnWriteArrayList**通过写时复制实现线程安全,适用于读多写少的场景,迭代器是快照迭代器。

第三,**BlockingQueue**支持阻塞操作,是实现生产者-消费者模式的基础。ArrayBlockingQueue使用单锁,LinkedBlockingQueue使用双锁。

第四,**同步队列**（SynchronousQueue）不存储元素,用于线程间的直接同步。

第五,**跳表集合**（ConcurrentSkipListMap/Set）提供有序性和O(log n)的操作复杂度。

选择合适的并发集合需要根据具体的访问模式、性能要求和一致性需求来决定。
