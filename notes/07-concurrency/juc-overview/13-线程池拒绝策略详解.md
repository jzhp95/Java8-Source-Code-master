# Java并发编程(JUC)体系源码深度解析——线程池拒绝策略详解

## 十三、线程池拒绝策略详解

### 13.1 拒绝策略概述

#### 13.1.1 为什么需要拒绝策略

在使用线程池时,当线程池无法接受新任务时(队列已满且线程数已达最大值),需要一个机制来处理被拒绝的任务。这就是拒绝策略的作用。拒绝策略决定了当线程池饱和时,如何处理新提交的任务。

拒绝策略的核心作用包括:

**防止系统过载**: 当线程池饱和时,拒绝新任务可以防止系统过载,避免资源耗尽。

**保证系统稳定性**: 通过合理的拒绝策略,可以保证系统在高负载下的稳定性。

**提供灵活的处理方式**: 不同的拒绝策略提供不同的处理方式,可以根据业务需求选择。

**避免任务丢失**: 某些拒绝策略可以避免任务丢失,如调用者运行策略。

#### 13.1.2 拒绝策略接口

拒绝策略通过RejectedExecutionHandler接口定义:

```java
public interface RejectedExecutionHandler {
    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
}
```

**参数说明:**

- r: 被拒绝的任务
- executor: 拒绝任务的线程池

**实现要求:**

拒绝策略的实现应该快速返回,避免阻塞线程池的调用者。如果拒绝策略需要执行耗时操作,应该在新线程中执行。

### 13.2 四种内置拒绝策略详解

#### 13.2.1 AbortPolicy(中止策略)

AbortPolicy是默认的拒绝策略,当任务被拒绝时,抛出RejectedExecutionException异常。

```java
public static class AbortPolicy implements RejectedExecutionHandler {
    public AbortPolicy() { }
    
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        throw new RejectedExecutionException("Task " + r.toString() +
                                             " rejected from " +
                                             e.toString());
    }
}
```

**特点:**

- 抛出异常,通知调用者任务被拒绝
- 需要调用者处理异常
- 可以快速失败,避免任务积压

**使用场景:**

- 需要快速失败的场景
- 调用者能够处理异常
- 不希望任务被静默丢弃

**使用示例:**

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    1, 1,
    0L, TimeUnit.MILLISECONDS,
    new LinkedBlockingQueue<>(1),
    new ThreadPoolExecutor.AbortPolicy()
);

try {
    executor.submit(() -> System.out.println("Task 1"));
    executor.submit(() -> System.out.println("Task 2"));
    executor.submit(() -> System.out.println("Task 3")); // 抛出异常
} catch (RejectedExecutionException e) {
    System.out.println("Task rejected: " + e.getMessage());
}
```

#### 13.2.2 CallerRunsPolicy(调用者运行策略)

CallerRunsPolicy当任务被拒绝时,由调用者线程(提交任务的线程)执行该任务。

```java
public static class CallerRunsPolicy implements RejectedExecutionHandler {
    public CallerRunsPolicy() { }
    
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        if (!e.isShutdown()) {
            r.run();
        }
    }
}
```

**特点:**

- 由调用者线程执行任务
- 可以减缓任务提交速度
- 避免任务丢失

**使用场景:**

- 不希望任务被丢弃
- 可以接受由调用者线程执行任务
- 需要减缓任务提交速度

**使用示例:**

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    1, 1,
    0L, TimeUnit.MILLISECONDS,
    new LinkedBlockingQueue<>(1),
    new ThreadPoolExecutor.CallerRunsPolicy()
);

executor.submit(() -> System.out.println("Task 1"));
executor.submit(() -> System.out.println("Task 2"));
executor.submit(() -> System.out.println("Task 3")); // 由调用者线程执行
```

**性能影响:**

CallerRuns策略会影响调用者线程的性能,因为调用者线程需要执行被拒绝的任务。这可以减缓任务提交速度,但也可能导致调用者线程阻塞。

#### 13.2.3 DiscardPolicy(丢弃策略)

DiscardPolicy当任务被拒绝时,直接丢弃任务,不做任何处理。

```java
public static class DiscardPolicy implements RejectedExecutionHandler {
    public DiscardPolicy() { }
    
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        // 什么都不做,直接丢弃任务
    }
}
```

**特点:**

- 静默丢弃任务
- 不抛出异常
- 不通知调用者

**使用场景:**

- 可以接受任务丢失
- 不希望影响系统性能
- 任务不重要,可以丢弃

**使用示例:**

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    1, 1,
    0L, TimeUnit.MILLISECONDS,
    new LinkedBlockingQueue<>(1),
    new ThreadPoolExecutor.DiscardPolicy()
);

executor.submit(() -> System.out.println("Task 1"));
executor.submit(() -> System.out.println("Task 2"));
executor.submit(() -> System.out.println("Task 3")); // 静默丢弃
```

**风险提示:**

Discard策略会导致任务丢失,调用者无法知道任务是否被处理。这种策略只适用于可以接受任务丢失的场景。

#### 13.2.4 DiscardOldestPolicy(丢弃最老任务策略)

DiscardOldestPolicy当任务被拒绝时,丢弃队列中最老的任务,然后重新尝试提交新任务。

```java
public static class DiscardOldestPolicy implements RejectedExecutionHandler {
    public DiscardOldestPolicy() { }
    
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        if (!e.isShutdown()) {
            e.getQueue().poll(); // 丢弃最老的任务
            e.execute(r); // 重新尝试提交新任务
        }
    }
}
```

**特点:**

- 丢弃队列中最老的任务
- 重新尝试提交新任务
- 保证新任务有机会执行

**使用场景:**

- 新任务比旧任务更重要
- 可以接受丢弃旧任务
- 需要保证新任务有机会执行

**使用示例:**

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    1, 1,
    0L, TimeUnit.MILLISECONDS,
    new LinkedBlockingQueue<>(1),
    new ThreadPoolExecutor.DiscardOldestPolicy()
);

executor.submit(() -> System.out.println("Task 1"));
executor.submit(() -> System.out.println("Task 2"));
executor.submit(() -> System.out.println("Task 3")); // 丢弃Task 1,执行Task 3
```

**风险提示:**

DiscardOldest策略会丢弃队列中的任务,可能导致某些任务永远不会被执行。这种策略只适用于新任务比旧任务更重要的场景。

### 13.3 自定义拒绝策略

#### 13.3.1 实现自定义拒绝策略

可以通过实现RejectedExecutionHandler接口来创建自定义拒绝策略:

```java
public class CustomRejectedExecutionHandler implements RejectedExecutionHandler {
    private final String name;
    
    public CustomRejectedExecutionHandler(String name) {
        this.name = name;
    }
    
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        System.out.println("Task rejected by " + name);
        System.out.println("Task: " + r.toString());
        System.out.println("Executor: " + executor.toString());
        
        // 自定义处理逻辑
        handleRejectedTask(r, executor);
    }
    
    private void handleRejectedTask(Runnable r, ThreadPoolExecutor executor) {
        // 可以在这里实现自定义的处理逻辑
        // 例如: 记录日志、发送告警、重试等
    }
}
```

**使用示例:**

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    1, 1,
    0L, TimeUnit.MILLISECONDS,
    new LinkedBlockingQueue<>(1),
    new CustomRejectedExecutionHandler("CustomHandler")
);

executor.submit(() -> System.out.println("Task 1"));
executor.submit(() -> System.out.println("Task 2"));
executor.submit(() -> System.out.println("Task 3")); // 触发自定义拒绝策略
```

#### 13.3.2 常见自定义拒绝策略场景

**1. 记录日志并丢弃:**

```java
public class LoggingDiscardPolicy implements RejectedExecutionHandler {
    private static final Logger logger = LoggerFactory.getLogger(LoggingDiscardPolicy.class);
    
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        logger.warn("Task rejected: {}", r.toString());
        logger.warn("Executor state: active={}, poolSize={}, queueSize={}",
                   executor.getActiveCount(),
                   executor.getPoolSize(),
                   executor.getQueue().size());
    }
}
```

**2. 重试机制:**

```java
public class RetryPolicy implements RejectedExecutionHandler {
    private final int maxRetries;
    private final long retryDelay;
    
    public RetryPolicy(int maxRetries, long retryDelay) {
        this.maxRetries = maxRetries;
        this.retryDelay = retryDelay;
    }
    
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        new Thread(() -> {
            int retries = 0;
            while (retries < maxRetries) {
                try {
                    Thread.sleep(retryDelay);
                    executor.execute(r);
                    return;
                } catch (RejectedExecutionException e) {
                    retries++;
                    if (retries >= maxRetries) {
                        System.out.println("Task rejected after " + maxRetries + " retries");
                        return;
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    return;
                }
            }
        }).start();
    }
}
```

**3. 发送告警:**

```java
public class AlertPolicy implements RejectedExecutionHandler {
    private final AlertService alertService;
    
    public AlertPolicy(AlertService alertService) {
        this.alertService = alertService;
    }
    
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        String message = String.format("Task rejected: %s, Executor: %s",
                                   r.toString(), executor.toString());
        alertService.sendAlert(message);
    }
}
```

### 13.4 拒绝策略选择指南

#### 13.4.1 选择拒绝策略的考虑因素

**1. 任务的重要性:**

- 重要任务: 使用CallerRunsPolicy或自定义策略,避免任务丢失
- 不重要任务: 使用DiscardPolicy或DiscardOldestPolicy

**2. 系统性能要求:**

- 高性能要求: 使用DiscardPolicy,避免阻塞
- 稳定性要求: 使用CallerRunsPolicy,减缓任务提交速度

**3. 异常处理能力:**

- 可以处理异常: 使用AbortPolicy,快速失败
- 不能处理异常: 使用CallerRunsPolicy或DiscardPolicy

**4. 任务时效性:**

- 新任务更重要: 使用DiscardOldestPolicy
- 旧任务更重要: 使用AbortPolicy或自定义策略

#### 13.4.2 拒绝策略对比

| 策略 | 处理方式 | 异常 | 任务丢失 | 适用场景 |
|------|---------|------|---------|---------|
| AbortPolicy | 抛出异常 | 是 | 否 | 需要快速失败 |
| CallerRunsPolicy | 调用者执行 | 否 | 否 | 不希望任务丢失 |
| DiscardPolicy | 静默丢弃 | 否 | 是 | 可以接受任务丢失 |
| DiscardOldestPolicy | 丢弃最老任务 | 否 | 是 | 新任务更重要 |

### 13.5 拒绝策略最佳实践

#### 13.5.1 合理配置线程池参数

```java
public class ThreadPoolConfig {
    public ThreadPoolExecutor createExecutor() {
        int corePoolSize = Runtime.getRuntime().availableProcessors();
        int maximumPoolSize = corePoolSize * 2;
        int queueCapacity = 100;
        long keepAliveTime = 60L;
        
        return new ThreadPoolExecutor(
            corePoolSize,
            maximumPoolSize,
            keepAliveTime,
            TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(queueCapacity),
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
    }
}
```

#### 13.5.2 监控拒绝事件

```java
public class MonitoredRejectedExecutionHandler implements RejectedExecutionHandler {
    private final RejectedExecutionHandler delegate;
    private final AtomicLong rejectCount = new AtomicLong(0);
    
    public MonitoredRejectedExecutionHandler(RejectedExecutionHandler delegate) {
        this.delegate = delegate;
    }
    
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        rejectCount.incrementAndGet();
        System.out.println("Total rejected tasks: " + rejectCount.get());
        delegate.rejectedExecution(r, executor);
    }
    
    public long getRejectCount() {
        return rejectCount.get();
    }
}
```

**使用示例:**

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    1, 1,
    0L, TimeUnit.MILLISECONDS,
    new LinkedBlockingQueue<>(1),
    new MonitoredRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy())
);
```

#### 13.5.3 动态调整拒绝策略

```java
public class DynamicRejectedExecutionHandler implements RejectedExecutionHandler {
    private volatile RejectedExecutionHandler currentHandler;
    
    public DynamicRejectedExecutionHandler(RejectedExecutionHandler initialHandler) {
        this.currentHandler = initialHandler;
    }
    
    public void setHandler(RejectedExecutionHandler handler) {
        this.currentHandler = handler;
    }
    
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        currentHandler.rejectedExecution(r, executor);
    }
}
```

**使用示例:**

```java
DynamicRejectedExecutionHandler handler = new DynamicRejectedExecutionHandler(
    new ThreadPoolExecutor.AbortPolicy()
);

ThreadPoolExecutor executor = new ThreadPoolExecutor(
    1, 1,
    0L, TimeUnit.MILLISECONDS,
    new LinkedBlockingQueue<>(1),
    handler
);

// 根据系统负载动态调整拒绝策略
if (systemLoad > 0.8) {
    handler.setHandler(new ThreadPoolExecutor.DiscardPolicy());
} else {
    handler.setHandler(new ThreadPoolExecutor.AbortPolicy());
}
```

### 13.6 小结

线程池拒绝策略是线程池饱和时处理被拒绝任务的机制,Java提供了四种内置拒绝策略,同时也支持自定义拒绝策略。

**核心要点总结:**

第一,**AbortPolicy**: 默认策略,抛出RejectedExecutionException异常,需要调用者处理异常。

第二,**CallerRunsPolicy**: 由调用者线程执行任务,可以减缓任务提交速度,避免任务丢失。

第三,**DiscardPolicy**: 静默丢弃任务,不做任何处理,适用于可以接受任务丢失的场景。

第四,**DiscardOldestPolicy**: 丢弃队列中最老的任务,重新尝试提交新任务,适用于新任务更重要的场景。

第五,**自定义拒绝策略**: 可以通过实现RejectedExecutionHandler接口创建自定义拒绝策略,实现更灵活的处理逻辑。

第六,**选择指南**: 根据任务重要性、系统性能要求、异常处理能力、任务时效性等因素选择合适的拒绝策略。

第七,**最佳实践**: 合理配置线程池参数、监控拒绝事件、动态调整拒绝策略。
