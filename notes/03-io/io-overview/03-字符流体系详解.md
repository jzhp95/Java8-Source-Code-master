# Java字符流体系详解

## 一、字符流体系架构

### 1.1 字符流层次结构

```
Reader（抽象基类）
├── FileReader（文件读取器）
├── CharArrayReader（字符数组读取器）
├── BufferedReader（缓冲读取器）
│   └── LineNumberReader（行号读取器）
├── StringReader（字符串读取器）
├── InputStreamReader（输入流转字符读取器）
├── FilterReader（过滤读取器基类）
│   └── PushbackReader（回退读取器）
└── PipedReader（管道读取器）

Writer（抽象基类）
├── FileWriter（文件写入器）
├── CharArrayWriter（字符数组写入器）
├── BufferedWriter（缓冲写入器）
├── StringWriter（字符串写入器）
├── OutputStreamWriter（输出流转字符写入器）
├── FilterWriter（过滤写入器基类）
├── PipedWriter（管道写入器）
└── PrintWriter（打印写入器）
```

### 1.2 字节流与字符流的转换

```
字节流 ←→ 字符流
  ↓          ↑
InputStreamReader  OutputStreamWriter
（字节流→字符流）  （字符流→字节流）
```

## 二、Reader抽象类详解

### 2.1 核心字段

```java
public abstract class Reader implements Readable, Closeable {
    // 同步锁对象
    protected Object lock;
}
```

**字段说明**：
- **lock**：用于同步操作的对象，可以是Reader本身或其他对象

### 2.2 构造方法

#### 2.2.1 默认构造方法

```java
protected Reader() {
    this.lock = this;
}
```

**特点**：使用Reader本身作为锁对象

#### 2.2.2 指定锁对象

```java
protected Reader(Object lock) {
    if (lock == null) {
        throw new NullPointerException();
    }
    this.lock = lock;
}
```

**特点**：使用指定的对象作为锁对象

### 2.3 核心方法

#### 2.3.1 read() - 读取单个字符

```java
public int read() throws IOException {
    char cb[] = new char[1];
    if (read(cb, 0, 1) == -1) {
        return -1;
    } else {
        return cb[0];
    }
}
```

**实现原理**：
- 创建单字符数组
- 调用read(char[], int, int)方法
- 返回读取的字符

#### 2.3.2 read(char cbuf[]) - 读取字符数组

```java
public int read(char cbuf[]) throws IOException {
    return read(cbuf, 0, cbuf.length);
}
```

#### 2.3.3 read(char cbuf[], int off, int len) - 读取指定范围

```java
abstract public int read(char cbuf[], int off, int len) throws IOException;
```

**特点**：抽象方法，子类必须实现

#### 2.3.4 read(CharBuffer target) - 读取到CharBuffer

```java
public int read(java.nio.CharBuffer target) throws IOException {
    int len = target.remaining();
    char[] cbuf = new char[len];
    int n = read(cbuf, 0, len);
    if (n > 0) {
        target.put(cbuf, 0, n);
    }
    return n;
}
```

**实现原理**：
- 获取CharBuffer剩余容量
- 创建字符数组
- 读取数据到数组
- 将数组数据写入CharBuffer

#### 2.3.5 skip(long n) - 跳过n个字符

```java
public long skip(long n) throws IOException {
    if (n < 0L) {
        throw new IllegalArgumentException("skip value is negative");
    } else if (n == 0L) {
        return 0L;
    }
    
    long nn = Math.min(n, maxSkipBufferSize);
    synchronized (lock) {
        if ((skipBuffer == null) || (skipBuffer.length < nn)) {
            skipBuffer = new char[(int)nn];
        }
        long r = n;
        while (r > 0) {
            int nr = read(skipBuffer, 0, (int)Math.min(r, skipBuffer.length));
            if (nr < 0) {
                break;
            }
            r -= nr;
        }
        return n - r;
    }
}
```

**实现原理**：
- 使用缓冲区读取并丢弃数据
- 最大缓冲区大小：maxSkipBufferSize
- 返回实际跳过的字符数

#### 2.3.6 ready() - 是否准备好读取

```java
public boolean ready() throws IOException {
    return false;
}
```

**默认实现**：返回false，子类可以重写

#### 2.3.7 markSupported() - 是否支持标记

```java
public boolean markSupported() {
    return false;
}
```

**默认实现**：返回false

#### 2.3.8 mark(int readAheadLimit) - 标记位置

```java
public void mark(int readAheadLimit) throws IOException {
    throw new IOException("mark not supported");
}
```

**默认实现**：抛出IOException

#### 2.3.9 reset() - 重置到标记位置

```java
public void reset() throws IOException {
    throw new IOException("reset not supported");
}
```

**默认实现**：抛出IOException

#### 2.3.10 close() - 关闭流

```java
abstract public void close() throws IOException;
```

**特点**：抽象方法，子类必须实现

## 三、BufferedReader详解

### 3.1 核心字段

```java
public class BufferedReader extends Reader {
    // 底层Reader
    private Reader in;
    
    // 字符缓冲区
    private char cb[];
    
    // 缓冲区中有效字符数量
    private int nChars, nextChar;
    
    // 标记相关
    private static final int INVALIDATED = -2;
    private static final int UNMARKED = -1;
    private int markedChar = UNMARKED;
    private int readAheadLimit = 0;
    
    // 跳过换行符标志
    private boolean skipLF = false;
    private boolean markedSkipLF = false;
    
    // 默认缓冲区大小
    private static int defaultCharBufferSize = 8192;
    private static int defaultExpectedLineLength = 80;
}
```

**字段说明**：
- **cb**：字符缓冲区
- **nChars**：缓冲区中有效字符数量
- **nextChar**：下一个要读取的字符位置
- **markedChar**：标记位置
- **readAheadLimit**：标记后最多可读取的字符数
- **skipLF**：是否跳过换行符

### 3.2 构造方法

#### 3.2.1 默认缓冲区大小

```java
public BufferedReader(Reader in) {
    this(in, defaultCharBufferSize);
}
```

#### 3.2.2 指定缓冲区大小

```java
public BufferedReader(Reader in, int sz) {
    super(in);
    if (sz <= 0) {
        throw new IllegalArgumentException("Buffer size <= 0");
    }
    this.in = in;
    cb = new char[sz];
    nextChar = nChars = 0;
}
```

### 3.3 核心方法

#### 3.3.1 read() - 读取单个字符

```java
public int read() throws IOException {
    synchronized (lock) {
        ensureOpen();
        if (nextChar >= nChars) {
            fill();
            if (nextChar >= nChars) {
                return -1;
            }
        }
        if (skipLF) {
            skipLF = false;
            if (cb[nextChar] == '\n') {
                nextChar++;
                if (nextChar >= nChars) {
                    fill();
                    if (nextChar >= nChars) {
                        return -1;
                    }
                }
            }
        }
        return cb[nextChar++];
    }
}
```

**读取流程**：
1. 同步锁
2. 检查流是否打开
3. 检查是否需要填充缓冲区
4. 处理skipLF标志
5. 返回当前字符，nextChar后移

#### 3.3.2 fill() - 填充缓冲区

```java
private void fill() throws IOException {
    int dst;
    if (markedChar <= UNMARKED) {
        dst = 0;
    } else {
        int delta = nextChar - markedChar;
        if (delta >= readAheadLimit) {
            markedChar = INVALIDATED;
            readAheadLimit = 0;
            dst = 0;
        } else {
            if (readAheadLimit <= cb.length) {
                System.arraycopy(cb, markedChar, cb, 0, delta);
                markedChar = 0;
                dst = delta;
            } else {
                char ncb[] = new char[readAheadLimit];
                System.arraycopy(cb, markedChar, ncb, 0, delta);
                cb = ncb;
                markedChar = 0;
                dst = delta;
            }
        }
    }
    
    int n;
    do {
        n = in.read(cb, dst, cb.length - dst);
    } while (n == 0);
    
    if (n > 0) {
        nChars = dst + n;
        nextChar = dst;
    }
}
```

**填充流程**：
1. 处理标记逻辑：
   - 如果未标记：重置dst为0
   - 如果已标记：
     - 如果超过readAheadLimit：丢弃标记
     - 否则：将标记后的数据移到缓冲区开头
2. 从底层Reader读取数据
3. 更新nChars和nextChar

#### 3.3.3 read(char cbuf[], int off, int len) - 读取字符数组

```java
public int read(char cbuf[], int off, int len) throws IOException {
    synchronized (lock) {
        ensureOpen();
        if ((off < 0) || (off > cbuf.length) || (len < 0) ||
            ((off + len) > cbuf.length) || ((off + len) < 0)) {
            throw new IndexOutOfBoundsException();
        } else if (len == 0) {
            return 0;
        }

        int n = read1(cbuf, off, len);
        if (n <= 0) return n;
        while ((n < len) && in.ready()) {
            int n1 = read1(cbuf, off + n, len - n);
            if (n1 <= 0) break;
            n += n1;
        }
        return n;
    }
}

private int read1(char[] cbuf, int off, int len) throws IOException {
    if (nextChar >= nChars) {
        if (len >= cb.length && markedChar <= UNMARKED && !skipLF) {
            return in.read(cbuf, off, len);
        }
        fill();
    }
    if (nextChar >= nChars) return -1;
    if (skipLF) {
        skipLF = false;
        if (cb[nextChar] == '\n') {
            nextChar++;
            if (nextChar >= nChars) {
                fill();
                if (nextChar >= nChars) return -1;
            }
        }
    }
    int n = Math.min(len, nChars - nextChar);
    System.arraycopy(cb, nextChar, cbuf, off, n);
    nextChar += n;
    return n;
}
```

**读取流程**：
1. 参数校验
2. 调用read1()读取数据
3. 如果底层流准备好，继续读取
4. read1()实现：
   - 检查缓冲区可用数据
   - 如果缓冲区为空且请求长度 >= 缓冲区大小，直接从底层流读取
   - 否则调用fill()填充缓冲区
   - 从缓冲区复制数据到目标数组

#### 3.3.4 readLine() - 读取一行

```java
public String readLine() throws IOException {
    synchronized (lock) {
        ensureOpen();
        boolean omitLF = skipLF;
        
        if (nextChar >= nChars) {
            fill();
        }
        if (nextChar >= nChars) {
            return null;
        }
        
        char c = 0;
        for (;;) {
            if (omitLF && (cb[nextChar] == '\n')) {
                nextChar++;
                omitLF = false;
                continue;
            }
            omitLF = false;
            if (nextChar >= nChars) {
                fill();
            }
            if (nextChar >= nChars) {
                break;
            }
            c = cb[nextChar++];
            if ((c == '\n') || (c == '\r')) {
                break;
            }
        }
        
        if ((c == '\r') && (nextChar < nChars) && (cb[nextChar] == '\n')) {
            nextChar++;
        }
        
        String s;
        if (nextChar == markedChar + 1) {
            s = null;
        } else {
            s = new String(cb, markedChar, nextChar - markedChar - 1);
        }
        nextChar = markedChar;
        markedChar = INVALIDATED;
        skipLF = false;
        return s;
    }
}
```

**读取流程**：
1. 同步锁
2. 处理skipLF标志
3. 循环读取字符直到遇到换行符
4. 处理Windows风格的换行符（\r\n）
5. 构造String对象
6. 重置标记位置

**换行符处理**：
- Unix：\n
- Windows：\r\n
- Mac（旧版）：\r

#### 3.3.5 mark(int readAheadLimit) - 标记位置

```java
public void mark(int readAheadLimit) throws IOException {
    if (readAheadLimit < 0) {
        throw new IllegalArgumentException("Read-ahead limit < 0");
    }
    synchronized (lock) {
        ensureOpen();
        this.readAheadLimit = readAheadLimit;
        markedChar = nextChar;
        markedSkipLF = skipLF;
    }
}
```

**标记操作**：
- 设置readAheadLimit
- 记录当前nextChar为markedChar
- 记录当前skipLF状态

#### 3.3.6 reset() - 重置到标记位置

```java
public void reset() throws IOException {
    synchronized (lock) {
        ensureOpen();
        if (markedChar < 0) {
            throw new IOException((markedChar == INVALIDATED) ? 
                "Mark invalid" : "Stream not marked");
        }
        nextChar = markedChar;
        skipLF = markedSkipLF;
    }
}
```

**重置操作**：
- 检查标记是否有效
- 重置nextChar为markedChar
- 重置skipLF为markedSkipLF

#### 3.3.7 markSupported() - 是否支持标记

```java
public boolean markSupported() {
    return true;
}
```

**特点**：BufferedReader支持标记功能

### 3.4 性能优化

**优点**：
- 减少底层Reader的调用次数
- 提高读取效率
- 支持按行读取
- 支持标记和重置

**性能提升**：
- 逐字符读取：从O(n)调用降低到O(1)
- 按行读取：减少字符编码转换次数

**使用建议**：
- 总是用BufferedReader包装基础Reader
- 大文件使用readLine()按行读取
- 根据需求调整缓冲区大小

## 四、InputStreamReader详解

### 4.1 核心字段

```java
public class InputStreamReader extends Reader {
    // 流解码器
    private final StreamDecoder sd;
}
```

**字段说明**：
- **sd**：StreamDecoder对象，负责字节到字符的解码

### 4.2 构造方法

#### 4.2.1 使用默认字符集

```java
public InputStreamReader(InputStream in) {
    super(in);
    try {
        sd = StreamDecoder.forInputStreamReader(in, this, (String)null);
    } catch (UnsupportedEncodingException e) {
        throw new Error(e);
    }
}
```

#### 4.2.2 使用指定字符集名称

```java
public InputStreamReader(InputStream in, String charsetName)
    throws UnsupportedEncodingException
{
    super(in);
    if (charsetName == null) {
        throw new NullPointerException("charsetName");
    }
    sd = StreamDecoder.forInputStreamReader(in, this, charsetName);
}
```

#### 4.2.3 使用指定Charset对象

```java
public InputStreamReader(InputStream in, Charset cs) {
    super(in);
    if (cs == null) {
        throw new NullPointerException("charset");
    }
    sd = StreamDecoder.forInputStreamReader(in, this, cs);
}
```

#### 4.2.4 使用指定CharsetDecoder

```java
public InputStreamReader(InputStream in, CharsetDecoder dec) {
    super(in);
    if (dec == null) {
        throw new NullPointerException("charset decoder");
    }
    sd = StreamDecoder.forInputStreamReader(in, this, dec);
}
```

### 4.3 核心方法

#### 4.3.1 read() - 读取单个字符

```java
public int read() throws IOException {
    return sd.read();
}
```

**实现原理**：委托给StreamDecoder.read()

#### 4.3.2 read(char cbuf[], int offset, int length) - 读取字符数组

```java
public int read(char cbuf[], int offset, int length) throws IOException {
    return sd.read(cbuf, offset, length);
}
```

#### 4.3.3 ready() - 是否准备好读取

```java
public boolean ready() throws IOException {
    return sd.ready();
}
```

#### 4.3.4 close() - 关闭流

```java
public void close() throws IOException {
    sd.close();
}
```

### 4.4 字符编码转换

**StreamDecoder工作原理**：
1. 从底层InputStream读取字节
2. 使用CharsetDecoder解码字节为字符
3. 处理字符编码转换
4. 返回解码后的字符

**常见字符集**：
- UTF-8：可变长度编码（1-4字节）
- UTF-16：固定长度编码（2字节）
- GBK：中文编码（2字节）
- ISO-8859-1：单字节编码

## 五、Writer抽象类详解

### 5.1 核心字段

```java
public abstract class Writer implements Appendable, Closeable, Flushable {
    // 写入缓冲区
    private char[] writeBuffer;
    private static final int WRITE_BUFFER_SIZE = 1024;
    
    // 同步锁对象
    protected Object lock;
}
```

**字段说明**：
- **writeBuffer**：写入缓冲区，用于优化单字符写入
- **lock**：同步锁对象

### 5.2 构造方法

#### 5.2.1 默认构造方法

```java
protected Writer() {
    this.lock = this;
}
```

#### 5.2.2 指定锁对象

```java
protected Writer(Object lock) {
    if (lock == null) {
        throw new NullPointerException();
    }
    this.lock = lock;
}
```

### 5.3 核心方法

#### 5.3.1 write(int c) - 写入单个字符

```java
public void write(int c) throws IOException {
    if (writeBuffer == null) {
        writeBuffer = new char[WRITE_BUFFER_SIZE];
    }
    writeBuffer[0] = (char) c;
    write(writeBuffer, 0, 1);
}
```

**实现原理**：
- 使用writeBuffer作为临时缓冲区
- 调用write(char[], int, int)方法

#### 5.3.2 write(char cbuf[]) - 写入字符数组

```java
public void write(char cbuf[]) throws IOException {
    write(cbuf, 0, cbuf.length);
}
```

#### 5.3.3 write(char cbuf[], int off, int len) - 写入指定范围

```java
abstract public void write(char cbuf[], int off, int len) throws IOException;
```

**特点**：抽象方法，子类必须实现

#### 5.3.4 write(String str) - 写入字符串

```java
public void write(String str) throws IOException {
    write(str, 0, str.length());
}
```

#### 5.3.5 write(String str, int off, int len) - 写入字符串的指定部分

```java
public void write(String str, int off, int len) throws IOException {
    char cbuf[];
    if (len <= WRITE_BUFFER_SIZE) {
        if (writeBuffer == null) {
            writeBuffer = new char[WRITE_BUFFER_SIZE];
        }
        cbuf = writeBuffer;
    } else {
        cbuf = new char[len];
    }
    str.getChars(off, off + len, cbuf, 0);
    write(cbuf, 0, len);
}
```

**实现原理**：
- 如果len <= WRITE_BUFFER_SIZE，使用writeBuffer
- 否则创建新的字符数组
- 调用String.getChars()复制字符
- 调用write(char[], int, int)写入

#### 5.3.6 append(CharSequence csq) - 追加字符序列

```java
public Writer append(CharSequence csq) throws IOException {
    if (csq == null) {
        write("null");
    } else {
        write(csq.toString());
    }
    return this;
}
```

#### 5.3.7 append(CharSequence csq, int start, int end) - 追加字符序列的指定部分

```java
public Writer append(CharSequence csq, int start, int end) throws IOException {
    CharSequence cs = (csq == null ? "null" : csq);
    write(cs.subSequence(start, end).toString());
    return this;
}
```

#### 5.3.8 append(char c) - 追加单个字符

```java
public Writer append(char c) throws IOException {
    write(c);
    return this;
}
```

#### 5.3.9 flush() - 刷新缓冲区

```java
abstract public void flush() throws IOException;
```

**特点**：抽象方法，子类必须实现

#### 5.3.10 close() - 关闭流

```java
abstract public void close() throws IOException;
```

**特点**：抽象方法，子类必须实现

## 六、BufferedWriter详解

### 6.1 核心字段

```java
public class BufferedWriter extends Writer {
    // 底层Writer
    private Writer out;
    
    // 字符缓冲区
    private char cb[];
    
    // 缓冲区中有效字符数量
    private int nChars, nextChar;
    
    // 默认缓冲区大小
    private static int defaultCharBufferSize = 8192;
    
    // 换行符
    private String lineSeparator;
}
```

**字段说明**：
- **cb**：字符缓冲区
- **nChars**：缓冲区容量
- **nextChar**：下一个写入位置
- **lineSeparator**：系统换行符

### 6.2 构造方法

#### 6.2.1 默认缓冲区大小

```java
public BufferedWriter(Writer out) {
    this(out, defaultCharBufferSize);
}
```

#### 6.2.2 指定缓冲区大小

```java
public BufferedWriter(Writer out, int sz) {
    super(out);
    if (sz <= 0) {
        throw new IllegalArgumentException("Buffer size <= 0");
    }
    this.out = out;
    cb = new char[sz];
    nChars = sz;
    nextChar = 0;
    lineSeparator = java.security.AccessController.doPrivileged(
        new sun.security.action.GetPropertyAction("line.separator"));
}
```

**构造流程**：
1. 调用父类构造方法
2. 参数校验
3. 创建字符缓冲区
4. 初始化nChars和nextChar
5. 获取系统换行符

### 6.3 核心方法

#### 6.3.1 write(int c) - 写入单个字符

```java
public void write(int c) throws IOException {
    synchronized (lock) {
        ensureOpen();
        if (nextChar >= nChars) {
            flushBuffer();
        }
        cb[nextChar++] = (char) c;
    }
}
```

**写入流程**：
1. 同步锁
2. 检查流是否打开
3. 检查缓冲区是否已满
4. 如果已满，调用flushBuffer()刷新缓冲区
5. 将字符写入缓冲区
6. nextChar后移

#### 6.3.2 flushBuffer() - 刷新缓冲区

```java
void flushBuffer() throws IOException {
    synchronized (lock) {
        ensureOpen();
        if (nextChar == 0) {
            return;
        }
        out.write(cb, 0, nextChar);
        nextChar = 0;
    }
}
```

**刷新流程**：
1. 同步锁
2. 检查流是否打开
3. 检查nextChar是否为0
4. 如果有数据，写入底层Writer
5. 重置nextChar为0

#### 6.3.3 write(char cbuf[], int off, int len) - 写入字符数组

```java
public void write(char cbuf[], int off, int len) throws IOException {
    synchronized (lock) {
        ensureOpen();
        if ((off < 0) || (off > cbuf.length) || (len < 0) ||
            ((off + len) > cbuf.length) || ((off + len) < 0)) {
            throw new IndexOutOfBoundsException();
        } else if (len == 0) {
            return;
        }

        if (len >= nChars) {
            flushBuffer();
            out.write(cbuf, off, len);
            return;
        }

        int b = off, t = off + len;
        while (b < t) {
            int d = min(nChars - nextChar, t - b);
            System.arraycopy(cbuf, b, cb, nextChar, d);
            b += d;
            nextChar += d;
            if (nextChar >= nChars) {
                flushBuffer();
            }
        }
    }
}
```

**写入流程**：
1. 参数校验
2. 如果len >= nChars：
   - 刷新缓冲区
   - 直接写入底层Writer
   - 返回
3. 否则：
   - 循环复制数据到缓冲区
   - 如果缓冲区已满，刷新缓冲区

#### 6.3.4 write(String s, int off, int len) - 写入字符串

```java
public void write(String s, int off, int len) throws IOException {
    synchronized (lock) {
        ensureOpen();
        int b = off, t = off + len;
        while (b < t) {
            int d = min(nChars - nextChar, t - b);
            s.getChars(b, b + d, cb, nextChar);
            b += d;
            nextChar += d;
            if (nextChar >= nChars) {
                flushBuffer();
            }
        }
    }
}
```

**写入流程**：
1. 同步锁
2. 检查流是否打开
3. 循环复制字符串字符到缓冲区
4. 如果缓冲区已满，刷新缓冲区

#### 6.3.5 newLine() - 写入换行符

```java
public void newLine() throws IOException {
    write(lineSeparator);
}
```

**实现原理**：写入系统换行符

#### 6.3.6 flush() - 刷新流

```java
public void flush() throws IOException {
    synchronized (lock) {
        flushBuffer();
        out.flush();
    }
}
```

**刷新流程**：
1. 刷新缓冲区
2. 调用底层Writer的flush()

### 6.4 性能优化

**优点**：
- 减少底层Writer的调用次数
- 提高写入效率
- 支持批量写入
- 支持换行符处理

**性能提升**：
- 逐字符写入：从O(n)调用降低到O(1)
- 批量写入：减少上下文切换

**使用建议**：
- 总是用BufferedWriter包装基础Writer
- 使用newLine()写入换行符（跨平台）
- 根据需求调整缓冲区大小

## 七、OutputStreamWriter详解

### 7.1 核心字段

```java
public class OutputStreamWriter extends Writer {
    // 流编码器
    private final StreamEncoder se;
}
```

**字段说明**：
- **se**：StreamEncoder对象，负责字符到字节的编码

### 7.2 构造方法

#### 7.2.1 使用默认字符集

```java
public OutputStreamWriter(OutputStream out) {
    super(out);
    try {
        se = StreamEncoder.forOutputStreamWriter(out, this, (String)null);
    } catch (UnsupportedEncodingException e) {
        throw new Error(e);
    }
}
```

#### 7.2.2 使用指定字符集名称

```java
public OutputStreamWriter(OutputStream out, String charsetName)
    throws UnsupportedEncodingException
{
    super(out);
    if (charsetName == null) {
        throw new NullPointerException("charsetName");
    }
    se = StreamEncoder.forOutputStreamWriter(out, this, charsetName);
}
```

#### 7.2.3 使用指定Charset对象

```java
public OutputStreamWriter(OutputStream out, Charset cs) {
    super(out);
    if (cs == null) {
        throw new NullPointerException("charset");
    }
    se = StreamEncoder.forOutputStreamWriter(out, this, cs);
}
```

#### 7.2.4 使用指定CharsetEncoder

```java
public OutputStreamWriter(OutputStream out, CharsetEncoder enc) {
    super(out);
    if (enc == null) {
        throw new NullPointerException("charset encoder");
    }
    se = StreamEncoder.forOutputStreamWriter(out, this, enc);
}
```

### 7.3 核心方法

#### 7.3.1 write(int c) - 写入单个字符

```java
public void write(int c) throws IOException {
    se.write(c);
}
```

#### 7.3.2 write(char cbuf[], int off, int len) - 写入字符数组

```java
public void write(char cbuf[], int off, int len) throws IOException {
    se.write(cbuf, off, len);
}
```

#### 7.3.3 write(String str, int off, int len) - 写入字符串

```java
public void write(String str, int off, int len) throws IOException {
    se.write(str, off, len);
}
```

#### 7.3.4 flush() - 刷新流

```java
public void flush() throws IOException {
    se.flush();
}
```

#### 7.3.5 close() - 关闭流

```java
public void close() throws IOException {
    se.close();
}
```

### 7.4 字符编码转换

**StreamEncoder工作原理**：
1. 接收字符输入
2. 使用CharsetEncoder编码字符为字节
3. 处理字符编码转换
4. 将字节写入底层OutputStream

## 八、使用示例

### 8.1 文本文件读取

```java
public static void readTextFile(String filename) throws IOException {
    try (BufferedReader reader = new BufferedReader(
            new InputStreamReader(
                new FileInputStream(filename), StandardCharsets.UTF_8))) {
        String line;
        while ((line = reader.readLine()) != null) {
            System.out.println(line);
        }
    }
}
```

### 8.2 文本文件写入

```java
public static void writeTextFile(String filename, List<String> lines) throws IOException {
    try (BufferedWriter writer = new BufferedWriter(
            new OutputStreamWriter(
                new FileOutputStream(filename), StandardCharsets.UTF_8))) {
        for (String line : lines) {
            writer.write(line);
            writer.newLine();
        }
    }
}
```

### 8.3 字符编码转换

```java
public static void convertEncoding(String srcFile, String destFile, 
        String srcEncoding, String destEncoding) throws IOException {
    try (BufferedReader reader = new BufferedReader(
            new InputStreamReader(
                new FileInputStream(srcFile), srcEncoding));
         BufferedWriter writer = new BufferedWriter(
            new OutputStreamWriter(
                new FileOutputStream(destFile), destEncoding))) {
        String line;
        while ((line = reader.readLine()) != null) {
            writer.write(line);
            writer.newLine();
        }
    }
}
```

### 8.4 字符流与字节流互转

```java
// 字节流转字符流
InputStream is = new FileInputStream("test.txt");
Reader reader = new InputStreamReader(is, StandardCharsets.UTF_8);

// 字符流转字节流
OutputStream os = new FileOutputStream("test.txt");
Writer writer = new OutputStreamWriter(os, StandardCharsets.UTF_8);
```

## 九、性能对比

### 9.1 FileReader vs BufferedReader

| 操作 | FileReader | BufferedReader | 性能提升 |
|------|------------|----------------|----------|
| 逐字符读取 | O(n)调用 | O(1)调用 | 100x+ |
| 按行读取 | 不支持 | 支持 | - |
| 批量读取 | O(n)调用 | O(n/bufSize)调用 | bufSize倍 |

### 9.2 FileWriter vs BufferedWriter

| 操作 | FileWriter | BufferedWriter | 性能提升 |
|------|-------------|----------------|----------|
| 逐字符写入 | O(n)调用 | O(1)调用 | 100x+ |
| 换行写入 | 需要手动 | newLine() | - |
| 批量写入 | O(n)调用 | O(n/bufSize)调用 | bufSize倍 |

## 十、最佳实践

### 10.1 总是使用缓冲流

```java
// 不推荐
Reader reader = new FileReader("test.txt");

// 推荐
Reader reader = new BufferedReader(new FileReader("test.txt"));
```

### 10.2 明确指定字符编码

```java
// 不推荐：使用平台默认编码
Reader reader = new InputStreamReader(new FileInputStream("test.txt"));

// 推荐：明确指定编码
Reader reader = new InputStreamReader(
    new FileInputStream("test.txt"), StandardCharsets.UTF_8);
```

### 10.3 使用try-with-resources

```java
// 推荐
try (BufferedReader reader = new BufferedReader(
        new FileReader("test.txt"))) {
    String line;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
}
```

### 10.4 使用newLine()写入换行符

```java
// 不推荐：硬编码换行符
writer.write("Hello\n");
writer.write("World\r\n");

// 推荐：使用newLine()
writer.write("Hello");
writer.newLine();
writer.write("World");
writer.newLine();
```

### 10.5 批量读写

```java
// 推荐：批量读取
char[] buffer = new char[8192];
int charsRead;
while ((charsRead = reader.read(buffer)) != -1) {
    // 处理buffer[0..charsRead-1]
}
```

## 十一、常见问题与解决方案

### 11.1 中文乱码问题

**原因**：字符编码不一致

**解决方案**：

```java
// 读取时指定编码
Reader reader = new InputStreamReader(
    new FileInputStream("test.txt"), "UTF-8");

// 写入时指定编码
Writer writer = new OutputStreamWriter(
    new FileOutputStream("test.txt"), "UTF-8");
```

### 11.2 换行符问题

**原因**：不同操作系统的换行符不同

**解决方案**：

```java
// 使用newLine()方法
writer.newLine();
```

### 11.3 性能问题

**原因**：未使用缓冲流

**解决方案**：

```java
// 总是使用缓冲流
Reader reader = new BufferedReader(new FileReader("test.txt"));
Writer writer = new BufferedWriter(new FileWriter("test.txt"));
```

## 十二、相关源码位置

| 类名 | 源码路径 |
|------|----------|
| Reader | src/main/jdk8/java/io/Reader.java |
| Writer | src/main/jdk8/java/io/Writer.java |
| BufferedReader | src/main/jdk8/java/io/BufferedReader.java |
| BufferedWriter | src/main/jdk8/java/io/BufferedWriter.java |
| InputStreamReader | src/main/jdk8/java/io/InputStreamReader.java |
| OutputStreamWriter | src/main/jdk8/java/io/OutputStreamWriter.java |
| FileReader | src/main/jdk8/java/io/FileReader.java |
| FileWriter | src/main/jdk8/java/io/FileWriter.java |
| CharArrayReader | src/main/jdk8/java/io/CharArrayReader.java |
| CharArrayWriter | src/main/jdk8/java/io/CharArrayWriter.java |
| StringReader | src/main/jdk8/java/io/StringReader.java |
| StringWriter | src/main/jdk8/java/io/StringWriter.java |
| FilterReader | src/main/jdk8/java/io/FilterReader.java |
| FilterWriter | src/main/jdk8/java/io/FilterWriter.java |
| PushbackReader | src/main/jdk8/java/io/PushbackReader.java |
| PipedReader | src/main/jdk8/java/io/PipedReader.java |
| PipedWriter | src/main/jdk8/java/io/PipedWriter.java |
| PrintWriter | src/main/jdk8/java/io/PrintWriter.java |
