# Java字节流体系详解

## 一、字节流体系架构

### 1.1 字节流层次结构

```
InputStream（抽象基类）
├── FileInputStream（文件输入流）
├── ByteArrayInputStream（字节数组输入流）
├── BufferedInputStream（缓冲输入流）
├── DataInputStream（数据输入流）
├── FilterInputStream（过滤输入流基类）
│   ├── BufferedInputStream
│   ├── DataInputStream
│   └── PushbackInputStream（回退输入流）
├── ObjectInputStream（对象输入流）
├── PipedInputStream（管道输入流）
├── SequenceInputStream（序列输入流）
└── PushbackInputStream（回退输入流）

OutputStream（抽象基类）
├── FileOutputStream（文件输出流）
├── ByteArrayOutputStream（字节数组输出流）
├── BufferedOutputStream（缓冲输出流）
├── DataOutputStream（数据输出流）
├── FilterOutputStream（过滤输出流基类）
│   ├── BufferedOutputStream
│   ├── DataOutputStream
│   └── PrintStream（打印输出流）
├── ObjectOutputStream（对象输出流）
├── PipedOutputStream（管道输出流）
└── PrintStream（打印输出流）
```

### 1.2 核心接口

```java
public interface Closeable extends AutoCloseable {
    void close() throws IOException;
}

public interface Flushable {
    void flush() throws IOException;
}
```

## 二、InputStream抽象类详解

### 2.1 核心字段

```java
public abstract class InputStream implements Closeable {
    // 跳过缓冲区的最大大小
    private static final int MAX_SKIP_BUFFER_SIZE = 2048;
}
```

### 2.2 核心方法

#### 2.2.1 read() - 读取单个字节

```java
public abstract int read() throws IOException;
```

**特点**：
- 抽象方法，子类必须实现
- 返回值范围：0-255
- 流末尾返回：-1
- 阻塞操作：直到有数据可用或到达流末尾

#### 2.2.2 read(byte b[]) - 读取字节数组

```java
public int read(byte b[]) throws IOException {
    return read(b, 0, b.length);
}
```

**实现原理**：调用read(byte[], int, int)方法

#### 2.2.3 read(byte b[], int off, int len) - 读取指定范围

```java
public int read(byte b[], int off, int len) throws IOException {
    if (b == null) {
        throw new NullPointerException();
    } else if (off < 0 || len < 0 || len > b.length - off) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return 0;
    }

    int c = read();
    if (c == -1) {
        return -1;
    }
    b[off] = (byte)c;

    int i = 1;
    try {
        for (; i < len ; i++) {
            c = read();
            if (c == -1) {
                break;
            }
            b[off + i] = (byte)c;
        }
    } catch (IOException ee) {
    }
    return i;
}
```

**实现特点**：
- 模板方法模式：提供默认实现
- 循环调用read()方法
- 异常处理：捕获IOException但不重新抛出
- 性能优化：子类可以重写此方法提高效率

#### 2.2.4 skip(long n) - 跳过n个字节

```java
public long skip(long n) throws IOException {
    long remaining = n;
    int nr;

    if (n <= 0) {
        return 0;
    }

    int size = (int)Math.min(MAX_SKIP_BUFFER_SIZE, remaining);
    byte[] skipBuffer = new byte[size];
    while (remaining > 0) {
        nr = read(skipBuffer, 0, (int)Math.min(size, remaining));
        if (nr < 0) {
            break;
        }
        remaining -= nr;
    }

    return n - remaining;
}
```

**实现原理**：
- 使用缓冲区读取并丢弃数据
- 最大缓冲区大小：2048字节
- 返回实际跳过的字节数

#### 2.2.5 available() - 可读取字节数

```java
public int available() throws IOException {
    return 0;
}
```

**默认实现**：返回0，子类可以重写

#### 2.2.6 close() - 关闭流

```java
public void close() throws IOException {}
```

**默认实现**：空方法，子类可以重写

#### 2.2.7 mark/reset - 标记与重置

```java
public boolean markSupported() {
    return false;
}

public void mark(int readlimit) {}

public void reset() throws IOException {
    throw new IOException("mark/reset not supported");
}
```

**默认实现**：
- markSupported()：返回false，表示不支持标记
- mark()：空方法
- reset()：抛出IOException

## 三、FileInputStream详解

### 3.1 核心字段

```java
public class FileInputStream extends InputStream {
    // 文件描述符
    private final FileDescriptor fd;
    
    // 文件路径
    private final String path;
    
    // 文件通道
    private FileChannel channel = null;
    
    // 关闭锁
    private final Object closeLock = new Object();
    
    // 关闭状态
    private volatile boolean closed = false;
}
```

**字段说明**：
- **fd**：文件描述符，表示打开的文件
- **path**：文件路径
- **channel**：NIO文件通道，支持零拷贝
- **closeLock**：关闭操作的锁对象
- **closed**：关闭状态标志，volatile保证可见性

### 3.2 构造方法

#### 3.2.1 通过文件名构造

```java
public FileInputStream(String name) throws FileNotFoundException {
    this(name != null ? new File(name) : null);
}
```

#### 3.2.2 通过File对象构造

```java
public FileInputStream(File file) throws FileNotFoundException {
    String name = (file != null ? file.getPath() : null);
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkRead(name);
    }
    if (name == null) {
        throw new NullPointerException();
    }
    if (file.isInvalid()) {
        throw new FileNotFoundException("Invalid file path");
    }
    fd = new FileDescriptor();
    fd.attach(this);
    path = name;
    open(name);
}
```

**构造流程**：
1. 获取文件路径
2. 安全检查：SecurityManager检查读取权限
3. 空指针检查
4. 路径有效性检查
5. 创建FileDescriptor对象
6. 关联FileDescriptor与FileInputStream
7. 调用native方法open()打开文件

#### 3.2.3 通过FileDescriptor构造

```java
public FileInputStream(FileDescriptor fdObj) {
    SecurityManager security = System.getSecurityManager();
    if (fdObj == null) {
        throw new NullPointerException();
    }
    if (security != null) {
        security.checkRead(fdObj);
    }
    this.fd = fdObj;
    path = null;
    fd.attach(this);
}
```

### 3.3 核心方法

#### 3.3.1 read() - 读取单个字节

```java
public int read() throws IOException {
    Object traceContext = IoTrace.fileReadBegin(path);
    int b = 0;
    try {
        b = read0();
    } finally {
        IoTrace.fileReadEnd(traceContext, b == -1 ? 0 : 1);
    }
    return b;
}

private native int read0() throws IOException;
```

**实现特点**：
- 调用native方法read0()
- 支持IO追踪
- 阻塞操作

#### 3.3.2 read(byte b[]) - 读取字节数组

```java
public int read(byte b[]) throws IOException {
    Object traceContext = IoTrace.fileReadBegin(path);
    int bytesRead = 0;
    try {
        bytesRead = readBytes(b, 0, b.length);
    } finally {
        IoTrace.fileReadEnd(traceContext, bytesRead);
    }
    return bytesRead;
}
```

#### 3.3.3 read(byte b[], int off, int len) - 读取指定范围

```java
public int read(byte b[], int off, int len) throws IOException {
    Object traceContext = IoTrace.fileReadBegin(path);
    int bytesRead = 0;
    try {
        bytesRead = readBytes(b, off, len);
    } finally {
        IoTrace.fileReadEnd(traceContext, bytesRead);
    }
    return bytesRead;
}

private native int readBytes(byte b[], int off, int len) throws IOException;
```

#### 3.3.4 skip(long n) - 跳过n个字节

```java
public long skip(long n) throws IOException {
    Object traceContext = IoTrace.fileReadBegin(path);
    long skipped = 0;
    try {
        skipped = skip0(n);
    } finally {
        IoTrace.fileReadEnd(traceContext, skipped);
    }
    return skipped;
}

private native long skip0(long n) throws IOException;
```

#### 3.3.5 available() - 可读取字节数

```java
public int available() throws IOException {
    Object traceContext = IoTrace.fileReadBegin(path);
    int available = 0;
    try {
        available = available0();
    } finally {
        IoTrace.fileReadEnd(traceContext, available);
    }
    return available;
}

private native int available0() throws IOException;
```

#### 3.3.6 close() - 关闭流

```java
public void close() throws IOException {
    synchronized (closeLock) {
        if (closed) {
            return;
        }
        closed = true;
    }
    
    if (channel != null) {
        channel.close();
    }
    
    fd.closeAll(new Closeable() {
        public void close() throws IOException {
            close0();
        }
    });
}

private native void close0() throws IOException;
```

**关闭流程**：
1. 同步检查关闭状态
2. 关闭FileChannel（如果存在）
3. 调用native方法close0()关闭文件描述符

#### 3.3.7 getChannel() - 获取文件通道

```java
public FileChannel getChannel() {
    synchronized (this) {
        if (channel == null) {
            channel = FileChannelImpl.open(fd, path, true, false, this);
        }
        return channel;
    }
}
```

**特点**：
- 延迟初始化：首次调用时创建FileChannel
- 线程安全：使用synchronized同步
- 支持NIO操作：零拷贝、内存映射等

### 3.4 性能特点

**优点**：
- 直接访问文件，效率高
- 支持NIO通道操作
- 支持文件定位

**缺点**：
- 每次read()都进行系统调用，效率低
- 不支持缓冲

**使用建议**：
- 总是用BufferedInputStream包装
- 大文件使用FileChannel进行零拷贝操作

## 四、BufferedInputStream详解

### 4.1 核心字段

```java
public class BufferedInputStream extends FilterInputStream {
    // 默认缓冲区大小：8KB
    private static int DEFAULT_BUFFER_SIZE = 8192;
    
    // 最大缓冲区大小
    private static int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;
    
    // 内部缓冲区数组
    protected volatile byte buf[];
    
    // 缓冲区更新器（用于原子操作）
    private static final AtomicReferenceFieldUpdater<BufferedInputStream, byte[]> bufUpdater =
        AtomicReferenceFieldUpdater.newUpdater(BufferedInputStream.class, byte[].class, "buf");
    
    // 缓冲区中有效数据的结束位置
    protected int count;
    
    // 当前读取位置
    protected int pos;
    
    // 标记位置
    protected int markpos = -1;
    
    // 标记限制
    protected int marklimit;
}
```

**字段说明**：
- **buf**：内部缓冲区，volatile保证可见性
- **count**：缓冲区中有效数据的结束位置
- **pos**：当前读取位置
- **markpos**：标记位置，-1表示未标记
- **marklimit**：标记后最多可读取的字节数

### 4.2 构造方法

#### 4.2.1 默认缓冲区大小

```java
public BufferedInputStream(InputStream in) {
    this(in, DEFAULT_BUFFER_SIZE);
}
```

#### 4.2.2 指定缓冲区大小

```java
public BufferedInputStream(InputStream in, int size) {
    super(in);
    if (size <= 0) {
        throw new IllegalArgumentException("Buffer size <= 0");
    }
    buf = new byte[size];
}
```

### 4.3 核心方法

#### 4.3.1 read() - 读取单个字节

```java
public synchronized int read() throws IOException {
    if (pos >= count) {
        fill();
        if (pos >= count) {
            return -1;
        }
    }
    return getBufIfOpen()[pos++] & 0xff;
}
```

**读取流程**：
1. 检查pos是否超过count
2. 如果超过，调用fill()填充缓冲区
3. 如果填充后仍然超过count，返回-1（流末尾）
4. 否则返回当前字节，pos后移

#### 4.3.2 fill() - 填充缓冲区

```java
private void fill() throws IOException {
    byte[] buffer = getBufIfOpen();
    if (markpos < 0) {
        pos = 0;
    } else if (pos >= buffer.length) {
        if (markpos > 0) {
            int sz = pos - markpos;
            System.arraycopy(buffer, markpos, buffer, 0, sz);
            pos = sz;
            markpos = 0;
        } else if (buffer.length >= marklimit) {
            markpos = -1;
            pos = 0;
        } else {
            int nsz = pos * 2;
            if (nsz > marklimit) {
                nsz = marklimit;
            }
            byte nbuf[] = new byte[nsz];
            System.arraycopy(buffer, 0, nbuf, 0, pos);
            if (!bufUpdater.compareAndSet(this, buffer, nbuf)) {
                throw new IOException("Stream closed");
            }
            buffer = nbuf;
        }
    }
    count = pos;
    int n = getInIfOpen().read(buffer, pos, buffer.length - pos);
    if (n > 0) {
        count = n + pos;
    }
}
```

**填充流程**：
1. 获取缓冲区引用
2. 处理标记逻辑：
   - 如果未标记（markpos < 0）：重置pos为0
   - 如果已标记且缓冲区已满：
     - 如果markpos > 0：将标记后的数据移到缓冲区开头
     - 如果markpos == 0且缓冲区大小 >= marklimit：丢弃标记
     - 否则：扩展缓冲区大小
3. 从底层流读取数据填充缓冲区
4. 更新count值

#### 4.3.3 read(byte b[], int off, int len) - 读取字节数组

```java
public synchronized int read(byte b[], int off, int len) throws IOException {
    getBufIfOpen();
    if ((off | len | (off + len) | (b.length - (off + len))) < 0) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return 0;
    }

    int n = 0;
    for (;;) {
        int nread = read1(b, off + n, len - n);
        if (nread <= 0) {
            return (n == 0) ? nread : n;
        }
        n += nread;
        if (n >= len) {
            return n;
        }
        if (in.available() <= 0) {
            return n;
        }
    }
}

private int read1(byte[] b, int off, int len) throws IOException {
    int avail = count - pos;
    if (avail <= 0) {
        if (len >= getBufIfOpen().length && markpos < 0) {
            return getInIfOpen().read(b, off, len);
        }
        fill();
        avail = count - pos;
        if (avail <= 0) {
            return -1;
        }
    }
    int cnt = (avail < len) ? avail : len;
    System.arraycopy(getBufIfOpen(), pos, b, off, cnt);
    pos += cnt;
    return cnt;
}
```

**读取流程**：
1. 参数校验
2. 循环读取：
   - 调用read1()读取数据
   - 如果读取到数据，累加到n
   - 如果n >= len，返回n
   - 如果底层流没有更多数据，返回n
3. read1()实现：
   - 检查缓冲区可用数据
   - 如果缓冲区为空：
     - 如果请求长度 >= 缓冲区大小且未标记，直接从底层流读取
     - 否则调用fill()填充缓冲区
   - 从缓冲区复制数据到目标数组
   - 更新pos

#### 4.3.4 skip(long n) - 跳过n个字节

```java
public synchronized long skip(long n) throws IOException {
    getBufIfOpen();
    if (n <= 0) {
        return 0;
    }
    long avail = count - pos;
    if (avail <= 0) {
        if (markpos < 0) {
            return getInIfOpen().skip(n);
        }
        fill();
        avail = count - pos;
        if (avail <= 0) {
            return 0;
        }
    }
    long skipped = (avail < n) ? avail : n;
    pos += skipped;
    return skipped;
}
```

**跳过流程**：
1. 检查n是否 <= 0
2. 计算缓冲区可用数据
3. 如果缓冲区为空：
   - 如果未标记，直接调用底层流的skip()
   - 否则调用fill()填充缓冲区
4. 从缓冲区跳过数据
5. 返回实际跳过的字节数

#### 4.3.5 mark(int readlimit) - 标记位置

```java
public synchronized void mark(int readlimit) {
    marklimit = readlimit;
    markpos = pos;
}
```

**标记操作**：
- 设置marklimit：标记后最多可读取的字节数
- 设置markpos：记录当前位置

#### 4.3.6 reset() - 重置到标记位置

```java
public synchronized void reset() throws IOException {
    getBufIfOpen();
    if (markpos < 0) {
        throw new IOException("Resetting to invalid mark");
    }
    pos = markpos;
}
```

**重置操作**：
- 检查是否已标记
- 将pos重置为markpos

#### 4.3.7 markSupported() - 是否支持标记

```java
public boolean markSupported() {
    return true;
}
```

**特点**：BufferedInputStream支持标记功能

### 4.4 性能优化

**优点**：
- 减少系统调用次数
- 提高读取效率
- 支持标记和重置

**性能提升**：
- 逐字节读取：从O(n)系统调用降低到O(1)
- 批量读取：减少上下文切换

**使用建议**：
- 总是用BufferedInputStream包装基础流
- 根据文件大小调整缓冲区大小
- 小文件：8KB（默认）
- 大文件：32KB或64KB

## 五、DataInputStream详解

### 5.1 核心字段

```java
public class DataInputStream extends FilterInputStream implements DataInput {
    // 工作数组（按需初始化）
    private byte bytearr[] = new byte[80];
    private char chararr[] = new char[80];
}
```

**字段说明**：
- **bytearr**：字节工作数组
- **chararr**：字符工作数组
- 用于readUTF()方法

### 5.2 核心方法

#### 5.2.1 readBoolean() - 读取布尔值

```java
public final boolean readBoolean() throws IOException {
    int ch = in.read();
    if (ch < 0) {
        throw new EOFException();
    }
    return (ch != 0);
}
```

**读取流程**：
- 读取一个字节
- 如果字节为0，返回false
- 否则返回true

#### 5.2.2 readByte() - 读取字节

```java
public final byte readByte() throws IOException {
    int ch = in.read();
    if (ch < 0) {
        throw new EOFException();
    }
    return (byte)(ch);
}
```

#### 5.2.3 readUnsignedByte() - 读取无符号字节

```java
public final int readUnsignedByte() throws IOException {
    int ch = in.read();
    if (ch < 0) {
        throw new EOFException();
    }
    return ch;
}
```

#### 5.2.4 readShort() - 读取短整型

```java
public final short readShort() throws IOException {
    int ch1 = in.read();
    int ch2 = in.read();
    if ((ch1 | ch2) < 0) {
        throw new EOFException();
    }
    return (short)((ch1 << 8) + (ch2 << 0));
}
```

**读取流程**：
- 读取两个字节
- 第一个字节为高8位
- 第二个字节为低8位
- 组合成short值

#### 5.2.5 readUnsignedShort() - 读取无符号短整型

```java
public final int readUnsignedShort() throws IOException {
    int ch1 = in.read();
    int ch2 = in.read();
    if ((ch1 | ch2) < 0) {
        throw new EOFException();
    }
    return (ch1 << 8) + (ch2 << 0);
}
```

#### 5.2.6 readChar() - 读取字符

```java
public final char readChar() throws IOException {
    int ch1 = in.read();
    int ch2 = in.read();
    if ((ch1 | ch2) < 0) {
        throw new EOFException();
    }
    return (char)((ch1 << 8) + (ch2 << 0));
}
```

#### 5.2.7 readInt() - 读取整型

```java
public final int readInt() throws IOException {
    int ch1 = in.read();
    int ch2 = in.read();
    int ch3 = in.read();
    int ch4 = in.read();
    if ((ch1 | ch2 | ch3 | ch4) < 0) {
        throw new EOFException();
    }
    return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));
}
```

**读取流程**：
- 读取四个字节
- 第一个字节为最高8位
- 第四个字节为最低8位
- 组合成int值

#### 5.2.8 readLong() - 读取长整型

```java
public final long readLong() throws IOException {
    readFully(bytearr, 0, 8);
    return (((long)bytearr[0] << 56) +
            ((long)(bytearr[1] & 255) << 48) +
            ((long)(bytearr[2] & 255) << 40) +
            ((long)(bytearr[3] & 255) << 32) +
            ((long)(bytearr[4] & 255) << 24) +
            ((bytearr[5] & 255) << 16) +
            ((bytearr[6] & 255) <<  8) +
            ((bytearr[7] & 255) <<  0));
}
```

**读取流程**：
- 读取8个字节到bytearr
- 组合成long值
- 使用&255确保无符号扩展

#### 5.2.9 readFloat() - 读取浮点数

```java
public final float readFloat() throws IOException {
    return Float.intBitsToFloat(readInt());
}
```

**实现原理**：
- 读取int值
- 使用Float.intBitsToFloat()转换为float

#### 5.2.10 readDouble() - 读取双精度浮点数

```java
public final double readDouble() throws IOException {
    return Double.longBitsToDouble(readLong());
}
```

**实现原理**：
- 读取long值
- 使用Double.longBitsToDouble()转换为double

#### 5.2.11 readUTF() - 读取UTF-8字符串

```java
public final String readUTF() throws IOException {
    return readUTF(this);
}

static final String readUTF(DataInput in) throws IOException {
    int utflen = in.readUnsignedShort();
    byte[] bytearr = null;
    char[] chararr = null;
    if (in instanceof DataInputStream) {
        DataInputStream dis = (DataInputStream)in;
        if (dis.bytearr.length < utflen) {
            dis.bytearr = new byte[utflen * 2];
            dis.chararr = new char[utflen * 2];
        }
        chararr = dis.chararr;
        bytearr = dis.bytearr;
    } else {
        bytearr = new byte[utflen];
        chararr = new char[utflen];
    }
    
    int c, char2, char3;
    int count = 0;
    int chararr_count = 0;
    
    in.readFully(bytearr, 0, utflen);
    
    while (count < utflen) {
        c = (int) bytearr[count] & 0xff;
        switch (c >> 4) {
            case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
                count++;
                chararr[chararr_count++] = (char)c;
                break;
            case 12: case 13:
                count += 2;
                if (count > utflen) {
                    throw new UTFDataFormatException();
                }
                char2 = (int) bytearr[count-1];
                if ((char2 & 0xC0) != 0x80) {
                    throw new UTFDataFormatException();
                }
                chararr[chararr_count++] = (char)(((c & 0x1F) << 6) |
                                                (char2 & 0x3F));
                break;
            case 14:
                count += 3;
                if (count > utflen) {
                    throw new UTFDataFormatException();
                }
                char2 = (int) bytearr[count-2];
                char3 = (int) bytearr[count-1];
                if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80)) {
                    throw new UTFDataFormatException();
                }
                chararr[chararr_count++] = (char)(((c & 0x0F) << 12) |
                                                ((char2 & 0x3F) << 6) |
                                                ((char3 & 0x3F) << 0));
                break;
            default:
                throw new UTFDataFormatException();
        }
    }
    return new String(chararr, 0, chararr_count);
}
```

**UTF-8编码规则**：
- 1字节：0xxxxxxx
- 2字节：110xxxxx 10xxxxxx
- 3字节：1110xxxx 10xxxxxx 10xxxxxx

**读取流程**：
1. 读取UTF-8字符串长度（2字节）
2. 读取所有字节
3. 解码UTF-8编码：
   - 根据第一个字节的高4位判断字节数
   - 解码为Unicode字符
4. 构造String对象

## 六、OutputStream抽象类详解

### 6.1 核心方法

#### 6.1.1 write(int b) - 写入单个字节

```java
public abstract void write(int b) throws IOException;
```

**特点**：
- 抽象方法，子类必须实现
- 只写入低8位，高24位被忽略

#### 6.1.2 write(byte b[]) - 写入字节数组

```java
public void write(byte b[]) throws IOException {
    write(b, 0, b.length);
}
```

#### 6.1.3 write(byte b[], int off, int len) - 写入指定范围

```java
public void write(byte b[], int off, int len) throws IOException {
    if (b == null) {
        throw new NullPointerException();
    } else if ((off < 0) || (off > b.length) || (len < 0) ||
               ((off + len) > b.length) || ((off + len) < 0)) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return;
    }
    for (int i = 0 ; i < len ; i++) {
        write(b[off + i]);
    }
}
```

**实现特点**：
- 模板方法模式：提供默认实现
- 循环调用write(int)方法
- 子类可以重写此方法提高效率

#### 6.1.4 flush() - 刷新缓冲区

```java
public void flush() throws IOException {}
```

**默认实现**：空方法，子类可以重写

#### 6.1.5 close() - 关闭流

```java
public void close() throws IOException {}
```

**默认实现**：空方法，子类可以重写

## 七、FileOutputStream详解

### 7.1 核心字段

```java
public class FileOutputStream extends OutputStream {
    // 文件描述符
    private final FileDescriptor fd;
    
    // 文件路径
    private final String path;
    
    // 是否为追加模式
    private final boolean append;
    
    // 文件通道
    private FileChannel channel;
    
    // 关闭锁
    private final Object closeLock = new Object();
    
    // 关闭状态
    private volatile boolean closed = false;
}
```

### 7.2 构造方法

#### 7.2.1 通过文件名构造

```java
public FileOutputStream(String name) throws FileNotFoundException {
    this(name != null ? new File(name) : null, false);
}

public FileOutputStream(String name, boolean append) throws FileNotFoundException {
    this(name != null ? new File(name) : null, append);
}
```

#### 7.2.2 通过File对象构造

```java
public FileOutputStream(File file) throws FileNotFoundException {
    this(file, false);
}

public FileOutputStream(File file, boolean append) throws FileNotFoundException {
    String name = (file != null ? file.getPath() : null);
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkWrite(name);
    }
    if (name == null) {
        throw new NullPointerException();
    }
    if (file.isInvalid()) {
        throw new FileNotFoundException("Invalid file path");
    }
    this.fd = new FileDescriptor();
    this.append = append;
    fd.attach(this);
    this.path = name;
    open(name, append);
}
```

**构造流程**：
1. 获取文件路径
2. 安全检查：SecurityManager检查写入权限
3. 空指针检查
4. 路径有效性检查
5. 创建FileDescriptor对象
6. 设置append标志
7. 关联FileDescriptor与FileOutputStream
8. 调用native方法open()打开文件

### 7.3 核心方法

#### 7.3.1 write(int b) - 写入单个字节

```java
public void write(int b) throws IOException {
    Object traceContext = IoTrace.fileWriteBegin(path);
    int bytesWritten = 0;
    try {
        write(b, fd);
        bytesWritten = 1;
    } finally {
        IoTrace.fileWriteEnd(traceContext, bytesWritten);
    }
}

private native void write(int b, FileDescriptor fd) throws IOException;
```

#### 7.3.2 write(byte b[]) - 写入字节数组

```java
public void write(byte b[]) throws IOException {
    Object traceContext = IoTrace.fileWriteBegin(path);
    int bytesWritten = 0;
    try {
        writeBytes(b, 0, b.length, fd);
        bytesWritten = b.length;
    } finally {
        IoTrace.fileWriteEnd(traceContext, bytesWritten);
    }
}
```

#### 7.3.3 write(byte b[], int off, int len) - 写入指定范围

```java
public void write(byte b[], int off, int len) throws IOException {
    Object traceContext = IoTrace.fileWriteBegin(path);
    int bytesWritten = 0;
    try {
        writeBytes(b, off, len, fd);
        bytesWritten = len;
    } finally {
        IoTrace.fileWriteEnd(traceContext, bytesWritten);
    }
}

private native void writeBytes(byte b[], int off, int len, FileDescriptor fd) throws IOException;
```

#### 7.3.4 close() - 关闭流

```java
public void close() throws IOException {
    synchronized (closeLock) {
        if (closed) {
            return;
        }
        closed = true;
    }
    
    if (channel != null) {
        channel.close();
    }
    
    fd.closeAll(new Closeable() {
        public void close() throws IOException {
            close0();
        }
    });
}

private native void close0() throws IOException;
```

#### 7.3.5 getFD() - 获取文件描述符

```java
public final FileDescriptor getFD() throws IOException {
    if (fd != null) {
        return fd;
    }
    throw new IOException();
}
```

#### 7.3.6 getChannel() - 获取文件通道

```java
public FileChannel getChannel() {
    synchronized (this) {
        if (channel == null) {
            channel = FileChannelImpl.open(fd, path, false, true, this);
        }
        return channel;
    }
}
```

## 八、BufferedOutputStream详解

### 8.1 核心字段

```java
public class BufferedOutputStream extends FilterOutputStream {
    // 内部缓冲区
    protected byte buf[];
    
    // 缓冲区中有效数据数量
    protected int count;
    
    // 默认缓冲区大小
    private static int defaultBufferSize = 8192;
}
```

### 8.2 构造方法

#### 8.2.1 默认缓冲区大小

```java
public BufferedOutputStream(OutputStream out) {
    this(out, defaultBufferSize);
}
```

#### 8.2.2 指定缓冲区大小

```java
public BufferedOutputStream(OutputStream out, int size) {
    super(out);
    if (size <= 0) {
        throw new IllegalArgumentException("Buffer size <= 0");
    }
    buf = new byte[size];
}
```

### 8.3 核心方法

#### 8.3.1 write(int b) - 写入单个字节

```java
public synchronized void write(int b) throws IOException {
    if (count >= buf.length) {
        flushBuffer();
    }
    buf[count++] = (byte)b;
}
```

**写入流程**：
1. 检查缓冲区是否已满
2. 如果已满，调用flushBuffer()刷新缓冲区
3. 将字节写入缓冲区
4. count后移

#### 8.3.2 flushBuffer() - 刷新缓冲区

```java
private void flushBuffer() throws IOException {
    if (count > 0) {
        out.write(buf, 0, count);
        count = 0;
    }
}
```

**刷新流程**：
1. 检查count是否 > 0
2. 如果有数据，写入底层流
3. 重置count为0

#### 8.3.3 write(byte b[], int off, int len) - 写入字节数组

```java
public synchronized void write(byte b[], int off, int len) throws IOException {
    if (len >= buf.length) {
        flushBuffer();
        out.write(b, off, len);
        return;
    }
    if (len > buf.length - count) {
        flushBuffer();
    }
    System.arraycopy(b, off, buf, count, len);
    count += len;
}
```

**写入流程**：
1. 如果len >= buf.length：
   - 刷新缓冲区
   - 直接写入底层流
   - 返回
2. 如果len > buf.length - count：
   - 刷新缓冲区
3. 复制数据到缓冲区
4. 更新count

#### 8.3.4 flush() - 刷新流

```java
public synchronized void flush() throws IOException {
    flushBuffer();
    out.flush();
}
```

**刷新流程**：
1. 刷新缓冲区
2. 调用底层流的flush()

### 8.4 性能优化

**优点**：
- 减少系统调用次数
- 提高写入效率
- 批量写入优化

**性能提升**：
- 逐字节写入：从O(n)系统调用降低到O(1)
- 批量写入：减少上下文切换

## 九、使用示例

### 9.1 文件复制

```java
public static void copyFile(String src, String dest) throws IOException {
    try (InputStream in = new BufferedInputStream(new FileInputStream(src));
         OutputStream out = new BufferedOutputStream(new FileOutputStream(dest))) {
        byte[] buffer = new byte[8192];
        int bytesRead;
        while ((bytesRead = in.read(buffer)) != -1) {
            out.write(buffer, 0, bytesRead);
        }
    }
}
```

### 9.2 读取二进制文件

```java
public static void readBinaryFile(String filename) throws IOException {
    try (InputStream in = new BufferedInputStream(new FileInputStream(filename));
         DataInputStream dis = new DataInputStream(in)) {
        int value = dis.readInt();
        double price = dis.readDouble();
        String name = dis.readUTF();
    }
}
```

### 9.3 写入二进制文件

```java
public static void writeBinaryFile(String filename) throws IOException {
    try (OutputStream out = new BufferedOutputStream(new FileOutputStream(filename));
         DataOutputStream dos = new DataOutputStream(out)) {
        dos.writeInt(123);
        dos.writeDouble(99.99);
        dos.writeUTF("Product Name");
    }
}
```

## 十、性能对比

### 10.1 FileInputStream vs BufferedInputStream

| 操作 | FileInputStream | BufferedInputStream | 性能提升 |
|------|----------------|---------------------|----------|
| 逐字节读取 | O(n)系统调用 | O(1)系统调用 | 100x+ |
| 批量读取 | O(n)系统调用 | O(n/bufSize)系统调用 | bufSize倍 |

### 10.2 FileOutputStream vs BufferedOutputStream

| 操作 | FileOutputStream | BufferedOutputStream | 性能提升 |
|------|------------------|---------------------|----------|
| 逐字节写入 | O(n)系统调用 | O(1)系统调用 | 100x+ |
| 批量写入 | O(n)系统调用 | O(n/bufSize)系统调用 | bufSize倍 |

## 十一、最佳实践

### 11.1 总是使用缓冲流

```java
// 不推荐
InputStream in = new FileInputStream("test.txt");

// 推荐
InputStream in = new BufferedInputStream(new FileInputStream("test.txt"));
```

### 11.2 使用try-with-resources

```java
// 不推荐
InputStream in = null;
try {
    in = new FileInputStream("test.txt");
    // 使用流
} finally {
    if (in != null) {
        in.close();
    }
}

// 推荐
try (InputStream in = new FileInputStream("test.txt")) {
    // 使用流
}
```

### 11.3 批量读写

```java
// 不推荐
int data;
while ((data = in.read()) != -1) {
    // 处理单个字节
}

// 推荐
byte[] buffer = new byte[8192];
int bytesRead;
while ((bytesRead = in.read(buffer)) != -1) {
    // 处理buffer[0..bytesRead-1]
}
```

### 11.4 合理设置缓冲区大小

```java
// 小文件：使用默认8KB
BufferedInputStream in = new BufferedInputStream(new FileInputStream("small.txt"));

// 大文件：增大缓冲区到32KB或64KB
BufferedInputStream in = new BufferedInputStream(
    new FileInputStream("large.txt"), 65536);
```

## 十二、相关源码位置

| 类名 | 源码路径 |
|------|----------|
| InputStream | src/main/jdk8/java/io/InputStream.java |
| OutputStream | src/main/jdk8/java/io/OutputStream.java |
| FileInputStream | src/main/jdk8/java/io/FileInputStream.java |
| FileOutputStream | src/main/jdk8/java/io/FileOutputStream.java |
| BufferedInputStream | src/main/jdk8/java/io/BufferedInputStream.java |
| BufferedOutputStream | src/main/jdk8/java/io/BufferedOutputStream.java |
| DataInputStream | src/main/jdk8/java/io/DataInputStream.java |
| DataOutputStream | src/main/jdk8/java/io/DataOutputStream.java |
| FilterInputStream | src/main/jdk8/java/io/FilterInputStream.java |
| FilterOutputStream | src/main/jdk8/java/io/FilterOutputStream.java |
