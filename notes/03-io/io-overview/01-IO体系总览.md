# Java IO体系源码深度解析

## 一、IO体系架构总览

Java IO（Input/Output）体系是Java核心库中用于处理输入输出操作的重要组成部分。Java IO体系设计遵循了良好的面向对象设计原则，提供了丰富的类和接口来处理各种类型的I/O操作。

### 1.1 IO体系分类

Java IO体系主要分为两大类：

1. **传统IO（BIO - Blocking I/O）**：基于流的阻塞式IO
   - 字节流：处理8位字节数据
   - 字符流：处理16位字符数据

2. **新IO（NIO - Non-blocking I/O）**：基于通道和缓冲区的非阻塞IO
   - Buffer：缓冲区
   - Channel：通道
   - Selector：选择器

### 1.2 IO体系层次结构

```
IO体系
├── 字节流（Byte Stream）
│   ├── InputStream（输入流基类）
│   │   ├── FileInputStream（文件输入流）
│   │   ├── ByteArrayInputStream（字节数组输入流）
│   │   ├── BufferedInputStream（缓冲输入流）
│   │   ├── DataInputStream（数据输入流）
│   │   ├── FilterInputStream（过滤输入流）
│   │   ├── ObjectInputStream（对象输入流）
│   │   ├── PipedInputStream（管道输入流）
│   │   ├── SequenceInputStream（序列输入流）
│   │   └── PushbackInputStream（回退输入流）
│   └── OutputStream（输出流基类）
│       ├── FileOutputStream（文件输出流）
│       ├── ByteArrayOutputStream（字节数组输出流）
│       ├── BufferedOutputStream（缓冲输出流）
│       ├── DataOutputStream（数据输出流）
│       ├── FilterOutputStream（过滤输出流）
│       ├── ObjectOutputStream（对象输出流）
│       ├── PipedOutputStream（管道输出流）
│       └── PrintStream（打印输出流）
├── 字符流（Character Stream）
│   ├── Reader（字符读取器基类）
│   │   ├── FileReader（文件读取器）
│   │   ├── CharArrayReader（字符数组读取器）
│   │   ├── BufferedReader（缓冲读取器）
│   │   ├── StringReader（字符串读取器）
│   │   ├── InputStreamReader（输入流转字符读取器）
│   │   ├── FilterReader（过滤读取器）
│   │   ├── PipedReader（管道读取器）
│   │   ├── LineNumberReader（行号读取器）
│   │   └── PushbackReader（回退读取器）
│   └── Writer（字符写入器基类）
│       ├── FileWriter（文件写入器）
│       ├── CharArrayWriter（字符数组写入器）
│       ├── BufferedWriter（缓冲写入器）
│       ├── StringWriter（字符串写入器）
│       ├── OutputStreamWriter（输出流转字符写入器）
│       ├── FilterWriter（过滤写入器）
│       ├── PipedWriter（管道写入器）
│       └── PrintWriter（打印写入器）
└── 文件操作（File Operations）
    ├── File（文件和目录路径抽象）
    ├── FileDescriptor（文件描述符）
    ├── RandomAccessFile（随机访问文件）
    └── FilenameFilter/FileFilter（文件过滤器）
```

## 二、核心接口与抽象类

### 2.1 Closeable接口

```java
public interface Closeable extends AutoCloseable {
    void close() throws IOException;
}
```

**作用**：定义资源关闭的统一接口，所有IO流都实现了此接口。

**设计模式**：模板方法模式，确保资源能够被正确释放。

**使用场景**：try-with-resources语法糖的支持。

### 2.2 Flushable接口

```java
public interface Flushable {
    void flush() throws IOException;
}
```

**作用**：定义刷新缓冲区的接口，用于强制将缓冲区数据写入目标。

**实现类**：所有输出流（OutputStream、Writer）都实现了此接口。

### 2.3 InputStream抽象类

**核心方法**：

```java
public abstract class InputStream implements Closeable {
    // 读取单个字节，返回0-255，到达流末尾返回-1
    public abstract int read() throws IOException;
    
    // 读取字节数组
    public int read(byte b[]) throws IOException {
        return read(b, 0, b.length);
    }
    
    // 读取指定范围的字节数组
    public int read(byte b[], int off, int len) throws IOException;
    
    // 跳过n个字节
    public long skip(long n) throws IOException;
    
    // 可读取的字节数
    public int available() throws IOException;
    
    // 关闭流
    public void close() throws IOException;
    
    // 标记当前位置
    public void mark(int readlimit);
    
    // 重置到标记位置
    public void reset() throws IOException;
    
    // 是否支持标记
    public boolean markSupported();
}
```

**设计特点**：
- 模板方法模式：提供默认实现，子类只需实现read()方法
- 装饰器模式：FilterInputStream及其子类提供装饰功能
- 适配器模式：将不同数据源适配为统一的输入流

### 2.4 OutputStream抽象类

**核心方法**：

```java
public abstract class OutputStream implements Closeable, Flushable {
    // 写入单个字节
    public abstract void write(int b) throws IOException;
    
    // 写入字节数组
    public void write(byte b[]) throws IOException {
        write(b, 0, b.length);
    }
    
    // 写入指定范围的字节数组
    public void write(byte b[], int off, int len) throws IOException;
    
    // 刷新缓冲区
    public void flush() throws IOException;
    
    // 关闭流
    public void close() throws IOException;
}
```

**设计特点**：
- 模板方法模式：提供默认实现，子类只需实现write(int)方法
- 装饰器模式：FilterOutputStream及其子类提供装饰功能

### 2.5 Reader抽象类

**核心方法**：

```java
public abstract class Reader implements Readable, Closeable {
    // 同步锁对象
    protected Object lock;
    
    // 读取单个字符
    public int read() throws IOException;
    
    // 读取字符数组
    public int read(char cbuf[]) throws IOException;
    
    // 读取指定范围的字符数组
    abstract public int read(char cbuf[], int off, int len) throws IOException;
    
    // 读取到CharBuffer
    public int read(java.nio.CharBuffer target) throws IOException;
    
    // 是否准备好读取
    public boolean ready() throws IOException;
    
    // 跳过字符
    public long skip(long n) throws IOException;
    
    // 是否支持标记
    public boolean markSupported();
    
    // 标记位置
    public void mark(int readAheadLimit) throws IOException;
    
    // 重置位置
    public void reset() throws IOException;
    
    // 关闭流
    abstract public void close() throws IOException;
}
```

**设计特点**：
- 线程安全：通过lock对象保证线程安全
- 字符编码处理：处理字符编码转换

### 2.6 Writer抽象类

**核心方法**：

```java
public abstract class Writer implements Appendable, Closeable, Flushable {
    // 写入缓冲区
    private char[] writeBuffer;
    private static final int WRITE_BUFFER_SIZE = 1024;
    
    // 同步锁对象
    protected Object lock;
    
    // 写入单个字符
    public void write(int c) throws IOException;
    
    // 写入字符数组
    public void write(char cbuf[]) throws IOException;
    
    // 写入指定范围的字符数组
    abstract public void write(char cbuf[], int off, int len) throws IOException;
    
    // 写入字符串
    public void write(String str) throws IOException;
    
    // 写入字符串的指定部分
    public void write(String str, int off, int len) throws IOException;
    
    // 追加字符
    public Writer append(char c) throws IOException;
    
    // 追加字符序列
    public Writer append(CharSequence csq) throws IOException;
    
    // 追加字符序列的指定部分
    public Writer append(CharSequence csq, int start, int end) throws IOException;
    
    // 刷新缓冲区
    abstract public void flush() throws IOException;
    
    // 关闭流
    abstract public void close() throws IOException;
}
```

**设计特点**：
- 缓冲优化：使用writeBuffer减少系统调用
- Appendable接口：支持链式调用
- 线程安全：通过lock对象保证线程安全

## 三、设计模式在IO体系中的应用

### 3.1 装饰器模式（Decorator Pattern）

**应用场景**：FilterInputStream和FilterOutputStream及其子类

**类图结构**：

```
InputStream（抽象组件）
├── FileInputStream（具体组件）
├── ByteArrayInputStream（具体组件）
└── FilterInputStream（装饰器基类）
    ├── BufferedInputStream（具体装饰器：缓冲）
    ├── DataInputStream（具体装饰器：数据类型转换）
    └── PushbackInputStream（具体装饰器：回退）
```

**使用示例**：

```java
// 基础流
InputStream in = new FileInputStream("test.txt");

// 添加缓冲功能
in = new BufferedInputStream(in);

// 添加数据读取功能
in = new DataInputStream(in);

// 读取数据
int value = in.readInt();
```

**优点**：
- 动态扩展功能：可以在运行时动态添加功能
- 灵活组合：可以任意组合装饰器
- 符合开闭原则：对扩展开放，对修改关闭

### 3.2 适配器模式（Adapter Pattern）

**应用场景**：InputStreamReader和OutputStreamWriter

**作用**：将字节流适配为字符流，处理字符编码转换。

**实现原理**：

```java
public class InputStreamReader extends Reader {
    private final StreamDecoder sd;
    
    public InputStreamReader(InputStream in) {
        super(in);
        sd = StreamDecoder.forInputStreamReader(in, this, 
            Charset.defaultCharset());
    }
    
    public int read(char cbuf[], int offset, int length) throws IOException {
        return sd.read(cbuf, offset, length);
    }
}
```

### 3.3 模板方法模式（Template Method Pattern）

**应用场景**：InputStream和OutputStream的批量读写方法

**实现原理**：

```java
// InputStream中的模板方法
public int read(byte b[], int off, int len) throws IOException {
    if (b == null) {
        throw new NullPointerException();
    } else if (off < 0 || len < 0 || len > b.length - off) {
        throw new IndexOutOfBoundsException();
    } else if (len == 0) {
        return 0;
    }
    
    int c = read();  // 调用抽象方法
    if (c == -1) {
        return -1;
    }
    b[off] = (byte)c;
    
    int i = 1;
    try {
        for (; i < len ; i++) {
            c = read();  // 调用抽象方法
            if (c == -1) {
                break;
            }
            b[off + i] = (byte)c;
        }
    } catch (IOException ee) {
    }
    return i;
}
```

**优点**：
- 代码复用：父类提供通用实现
- 灵活性：子类可以重写特定方法优化性能

### 3.4 工厂方法模式（Factory Method Pattern）

**应用场景**：FileSystem抽象类

**实现原理**：

```java
abstract class FileSystem {
    // 工厂方法：创建File对象
    public abstract File createFile(String path);
    
    // 获取文件系统实例
    static FileSystem getFileSystem() {
        return DefaultFileSystem.getFileSystem();
    }
}
```

## 四、字节流与字符流的区别

### 4.1 字节流（Byte Stream）

**特点**：
- 处理8位字节数据
- 不涉及字符编码
- 适合处理二进制数据（图片、音频、视频等）
- 基类：InputStream、OutputStream

**典型实现**：
- FileInputStream/FileOutputStream：文件操作
- ByteArrayInputStream/ByteArrayOutputStream：内存操作
- BufferedInputStream/BufferedOutputStream：缓冲操作

### 4.2 字符流（Character Stream）

**特点**：
- 处理16位字符数据
- 涉及字符编码转换（UTF-8、GBK等）
- 适合处理文本数据
- 基类：Reader、Writer

**典型实现**：
- FileReader/FileWriter：文件操作
- CharArrayReader/CharArrayWriter：内存操作
- BufferedReader/BufferedWriter：缓冲操作
- InputStreamReader/OutputStreamWriter：字节流与字符流转换

### 4.3 转换关系

```
字节流 ←→ 字符流
  ↓          ↑
InputStreamReader  OutputStreamWriter
（字节流→字符流）  （字符流→字节流）
```

**使用示例**：

```java
// 字节流转字符流
InputStream is = new FileInputStream("test.txt");
Reader reader = new InputStreamReader(is, "UTF-8");

// 字符流转字节流
OutputStream os = new FileOutputStream("test.txt");
Writer writer = new OutputStreamWriter(os, "UTF-8");
```

## 五、IO流的分类与使用场景

### 5.1 按数据流向分类

| 类型 | 输入流 | 输出流 |
|------|--------|--------|
| 字节流 | InputStream | OutputStream |
| 字符流 | Reader | Writer |

### 5.2 按数据来源/目标分类

| 数据源 | 字节流 | 字符流 |
|--------|--------|--------|
| 文件 | FileInputStream/FileOutputStream | FileReader/FileWriter |
| 数组 | ByteArrayInputStream/ByteArrayOutputStream | CharArrayReader/CharArrayWriter |
| 管道 | PipedInputStream/PipedOutputStream | PipedReader/PipedWriter |
| 字符串 | - | StringReader/StringWriter |
| 网络 | Socket.getInputStream()/Socket.getOutputStream() | - |

### 5.3 按功能分类

| 功能 | 字节流 | 字符流 |
|------|--------|--------|
| 缓冲 | BufferedInputStream/BufferedOutputStream | BufferedReader/BufferedWriter |
| 数据类型 | DataInputStream/DataOutputStream | - |
| 对象 | ObjectInputStream/ObjectOutputStream | - |
| 打印 | PrintStream | PrintWriter |
| 过滤 | FilterInputStream/FilterOutputStream | FilterReader/FilterWriter |
| 回退 | PushbackInputStream | PushbackReader |

## 六、IO流的使用最佳实践

### 6.1 资源释放

**推荐方式**：使用try-with-resources

```java
// Java 7+ 推荐
try (InputStream is = new FileInputStream("test.txt");
     BufferedInputStream bis = new BufferedInputStream(is)) {
    int data;
    while ((data = bis.read()) != -1) {
        // 处理数据
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

### 6.2 缓冲流的使用

**原则**：总是使用缓冲流包装基础流

```java
// 不推荐：直接使用FileInputStream
try (InputStream is = new FileInputStream("test.txt")) {
    // 每次read()都会进行系统调用，效率低
}

// 推荐：使用BufferedInputStream包装
try (InputStream is = new BufferedInputStream(
        new FileInputStream("test.txt"))) {
    // 减少系统调用次数，提高效率
}
```

### 6.3 字符编码处理

**原则**：明确指定字符编码

```java
// 不推荐：使用平台默认编码
Reader reader = new InputStreamReader(new FileInputStream("test.txt"));

// 推荐：明确指定编码
Reader reader = new InputStreamReader(
    new FileInputStream("test.txt"), StandardCharsets.UTF_8);
```

### 6.4 批量读写

**原则**：使用批量读写方法提高效率

```java
// 不推荐：逐字节读取
int data;
while ((data = is.read()) != -1) {
    // 处理单个字节
}

// 推荐：批量读取
byte[] buffer = new byte[8192];
int bytesRead;
while ((bytesRead = is.read(buffer)) != -1) {
    // 处理buffer[0..bytesRead-1]
}
```

## 七、IO性能优化

### 7.1 缓冲区大小选择

**默认缓冲区大小**：
- BufferedInputStream/BufferedOutputStream：8192字节（8KB）
- BufferedReader/BufferedWriter：8192字符

**优化建议**：
- 小文件：使用默认缓冲区大小
- 大文件：增大缓冲区大小（如32KB、64KB）
- 内存敏感：减小缓冲区大小

### 7.2 批量操作

**批量读写优势**：
- 减少系统调用次数
- 减少上下文切换
- 提高缓存命中率

### 7.3 NIO的优势

**NIO（New I/O）特点**：
- 非阻塞IO
- 多路复用
- 内存映射文件
- 零拷贝

**适用场景**：
- 高并发网络编程
- 大文件处理
- 需要高性能IO的场景

## 八、常见问题与解决方案

### 8.1 中文乱码问题

**原因**：字符编码不一致

**解决方案**：

```java
// 读取时指定编码
Reader reader = new InputStreamReader(
    new FileInputStream("test.txt"), "UTF-8");

// 写入时指定编码
Writer writer = new OutputStreamWriter(
    new FileOutputStream("test.txt"), "UTF-8");
```

### 8.2 内存溢出问题

**原因**：一次性读取大文件到内存

**解决方案**：

```java
// 不推荐：一次性读取整个文件
byte[] data = Files.readAllBytes(Paths.get("largefile.txt"));

// 推荐：分批读取
try (InputStream is = new BufferedInputStream(
        new FileInputStream("largefile.txt"))) {
    byte[] buffer = new byte[8192];
    int bytesRead;
    while ((bytesRead = is.read(buffer)) != -1) {
        // 处理每个buffer
    }
}
```

### 8.3 资源泄漏问题

**原因**：未正确关闭IO流

**解决方案**：

```java
// 使用try-with-resources确保资源释放
try (InputStream is = new FileInputStream("test.txt")) {
    // 使用流
} catch (IOException e) {
    e.printStackTrace();
}
// 流会自动关闭
```

## 九、IO体系总结

### 9.1 设计原则

1. **单一职责原则**：每个类只负责一种功能
2. **开闭原则**：对扩展开放，对修改关闭
3. **里氏替换原则**：子类可以替换父类
4. **接口隔离原则**：使用细粒度接口
5. **依赖倒置原则**：依赖抽象而非具体实现

### 9.2 核心思想

1. **流式处理**：数据以流的形式传输
2. **装饰器模式**：动态扩展功能
3. **适配器模式**：统一不同数据源
4. **模板方法模式**：提供通用实现
5. **工厂方法模式**：创建对象

### 9.3 使用建议

1. **优先使用缓冲流**：提高IO效率
2. **明确指定字符编码**：避免乱码
3. **使用try-with-resources**：确保资源释放
4. **批量读写**：减少系统调用
5. **选择合适的流类型**：字节流vs字符流

## 十、相关源码位置

| 类名 | 源码路径 |
|------|----------|
| InputStream | src/main/jdk8/java/io/InputStream.java |
| OutputStream | src/main/jdk8/java/io/OutputStream.java |
| Reader | src/main/jdk8/java/io/Reader.java |
| Writer | src/main/jdk8/java/io/Writer.java |
| FileInputStream | src/main/jdk8/java/io/FileInputStream.java |
| FileOutputStream | src/main/jdk8/java/io/FileOutputStream.java |
| BufferedInputStream | src/main/jdk8/java/io/BufferedInputStream.java |
| BufferedOutputStream | src/main/jdk8/java/io/BufferedOutputStream.java |
| BufferedReader | src/main/jdk8/java/io/BufferedReader.java |
| BufferedWriter | src/main/jdk8/java/io/BufferedWriter.java |
| InputStreamReader | src/main/jdk8/java/io/InputStreamReader.java |
| OutputStreamWriter | src/main/jdk8/java/io/OutputStreamWriter.java |
| File | src/main/jdk8/java/io/File.java |
| RandomAccessFile | src/main/jdk8/java/io/RandomAccessFile.java |
