# Java文件操作详解

## 一、File类详解

### 1.1 File类概述

**File类作用**：
- 文件和目录路径的抽象表示
- 提供文件和目录的创建、删除、重命名等操作
- 提供文件属性查询（大小、修改时间、权限等）

**特点**：
- 不可变对象：一旦创建，路径不会改变
- 跨平台：处理不同操作系统的路径分隔符
- 不涉及文件内容：只处理文件元数据和路径

### 1.2 核心字段

```java
public class File implements Serializable, Comparable<File> {
    // 路径分隔符
    public static final String separator = "" + separatorChar;
    public static final char separatorChar;
    
    // 路径分隔符（用于环境变量PATH）
    public static final String pathSeparator = "" + pathSeparatorChar;
    public static final char pathSeparatorChar;
    
    // 抽象路径名
    private final String path;
    
    // 文件系统前缀长度
    private transient int prefixLength;
    
    // 文件系统
    private static final FileSystem fs = FileSystem.getFileSystem();
}
```

**字段说明**：
- **separator**：路径分隔符（Unix: "/"，Windows: "\"）
- **pathSeparator**：路径分隔符（Unix: "："，Windows: ";"）
- **path**：抽象路径名
- **prefixLength**：文件系统前缀长度

### 1.3 构造方法

#### 1.3.1 通过路径名构造

```java
public File(String pathname) {
    if (pathname == null) {
        throw new NullPointerException();
    }
    this.path = fs.normalize(pathname);
    this.prefixLength = fs.prefixLength(this.path);
}
```

**构造流程**：
1. 检查路径名是否为null
2. 规范化路径名
3. 计算前缀长度

#### 1.3.2 通过父路径和子路径构造

```java
public File(String parent, String child) {
    if (child == null) {
        throw new NullPointerException();
    }
    if (parent != null) {
        if (parent.equals("")) {
            this.path = fs.resolve(fs.getDefaultParent(), fs.normalize(child));
        } else {
            this.path = fs.resolve(fs.normalize(parent), fs.normalize(child));
        }
    } else {
        this.path = fs.normalize(child);
    }
    this.prefixLength = fs.prefixLength(this.path);
}
```

#### 1.3.3 通过父File对象和子路径构造

```java
public File(File parent, String child) {
    if (child == null) {
        throw new NullPointerException();
    }
    if (parent != null) {
        if (parent.path.equals("")) {
            this.path = fs.resolve(fs.getDefaultParent(), fs.normalize(child));
        } else {
            this.path = fs.resolve(parent.path, fs.normalize(child));
        }
    } else {
        this.path = fs.normalize(child);
    }
    this.prefixLength = fs.prefixLength(this.path);
}
```

#### 1.3.4 通过URI构造

```java
public File(URI uri) {
    if (!uri.isAbsolute()) {
        throw new IllegalArgumentException("URI is not absolute");
    }
    if (uri.isOpaque()) {
        throw new IllegalArgumentException("URI is not hierarchical");
    }
    String scheme = uri.getScheme();
    if ((scheme == null) || !scheme.equalsIgnoreCase("file")) {
        throw new IllegalArgumentException("URI scheme is not \"file\"");
    }
    if (uri.getAuthority() != null) {
        throw new IllegalArgumentException("URI has an authority component");
    }
    if (uri.getFragment() != null) {
        throw new IllegalArgumentException("URI has a fragment component");
    }
    if (uri.getQuery() != null) {
        throw new IllegalArgumentException("URI has a query component");
    }
    
    String p = uri.getPath();
    if (p.equals("")) {
        throw new IllegalArgumentException("URI path component is empty");
    }
    
    this.path = fs.normalize(p);
    this.prefixLength = fs.prefixLength(this.path);
}
```

### 1.4 路径操作方法

#### 1.4.1 getName() - 获取文件名

```java
public String getName() {
    int index = path.lastIndexOf(separatorChar);
    if (index < prefixLength) {
        return path.substring(prefixLength);
    }
    return path.substring(index + 1);
}
```

**实现原理**：
- 查找最后一个路径分隔符
- 返回分隔符后的部分

#### 1.4.2 getParent() - 获取父路径

```java
public String getParent() {
    int index = path.lastIndexOf(separatorChar);
    if (index < prefixLength) {
        if ((prefixLength > 0) && (path.length() > prefixLength)) {
            return path.substring(0, prefixLength);
        }
        return null;
    }
    return path.substring(0, index);
}
```

**实现原理**：
- 查找最后一个路径分隔符
- 返回分隔符前的部分

#### 1.4.3 getParentFile() - 获取父File对象

```java
public File getParentFile() {
    String p = this.getParent();
    if (p == null) {
        return null;
    }
    return new File(p, this.prefixLength);
}
```

#### 1.4.4 getPath() - 获取路径

```java
public String getPath() {
    return path;
}
```

#### 1.4.5 getAbsolutePath() - 获取绝对路径

```java
public String getAbsolutePath() {
    return fs.resolve(this);
}
```

#### 1.4.6 getAbsoluteFile() - 获取绝对路径File对象

```java
public File getAbsoluteFile() {
    String absPath = getAbsolutePath();
    return new File(absPath, fs.prefixLength(absPath));
}
```

#### 1.4.7 getCanonicalPath() - 获取规范路径

```java
public String getCanonicalPath() throws IOException {
    if (isInvalid()) {
        throw new IOException("Invalid file path");
    }
    return fs.canonicalize(fs.resolve(this));
}
```

**规范路径特点**：
- 解析符号链接
- 解析"."和".."
- 返回唯一的绝对路径

#### 1.4.8 getCanonicalFile() - 获取规范路径File对象

```java
public File getCanonicalFile() throws IOException {
    String canonPath = getCanonicalPath();
    return new File(canonPath, fs.prefixLength(canonPath));
}
```

### 1.5 文件属性查询方法

#### 1.5.1 exists() - 文件是否存在

```java
public boolean exists() {
    if (isInvalid()) {
        return false;
    }
    return ((fs.getBooleanAttributes(this) & FileSystem.BA_EXISTS) != 0);
}
```

#### 1.5.2 isDirectory() - 是否为目录

```java
public boolean isDirectory() {
    if (isInvalid()) {
        return false;
    }
    return ((fs.getBooleanAttributes(this) & FileSystem.BA_DIRECTORY) != 0);
}
```

#### 1.5.3 isFile() - 是否为文件

```java
public boolean isFile() {
    if (isInvalid()) {
        return false;
    }
    return ((fs.getBooleanAttributes(this) & FileSystem.BA_REGULAR) != 0);
}
```

#### 1.5.4 isHidden() - 是否为隐藏文件

```java
public boolean isHidden() {
    if (isInvalid()) {
        return false;
    }
    return ((fs.getBooleanAttributes(this) & FileSystem.BA_HIDDEN) != 0);
}
```

#### 1.5.5 canRead() - 是否可读

```java
public boolean canRead() {
    if (isInvalid()) {
        return false;
    }
    return fs.checkAccess(this, FileSystem.ACCESS_READ);
}
```

#### 1.5.6 canWrite() - 是否可写

```java
public boolean canWrite() {
    if (isInvalid()) {
        return false;
    }
    return fs.checkAccess(this, FileSystem.ACCESS_WRITE);
}
```

#### 1.5.7 canExecute() - 是否可执行

```java
public boolean canExecute() {
    if (isInvalid()) {
        return false;
    }
    return fs.checkAccess(this, FileSystem.ACCESS_EXECUTE);
}
```

#### 1.5.8 lastModified() - 获取最后修改时间

```java
public long lastModified() {
    if (isInvalid()) {
        return 0;
    }
    return fs.getLastModifiedTime(this);
}
```

#### 1.5.9 length() - 获取文件大小

```java
public long length() {
    if (isInvalid()) {
        return 0;
    }
    return fs.getLength(this);
}
```

### 1.6 文件操作方法

#### 1.6.1 createNewFile() - 创建新文件

```java
public boolean createNewFile() throws IOException {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkWrite(path);
    }
    if (isInvalid()) {
        throw new IOException("Invalid file path");
    }
    return fs.createFileExclusively(path);
}
```

**特点**：
- 原子操作：如果文件已存在，返回false
- 抛出IOException：如果创建失败

#### 1.6.2 delete() - 删除文件或目录

```java
public boolean delete() {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkDelete(path);
    }
    if (isInvalid()) {
        return false;
    }
    return fs.delete(this);
}
```

**特点**：
- 如果是目录，必须为空才能删除
- 返回true表示删除成功

#### 1.6.3 deleteOnExit() - 退出时删除

```java
public void deleteOnExit() {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkDelete(path);
    }
    if (isInvalid()) {
        throw new IllegalArgumentException("Invalid file path");
    }
    DeleteOnExitHook.add(path);
}
```

**特点**：
- JVM退出时自动删除文件
- 适用于临时文件

#### 1.6.4 mkdir() - 创建目录

```java
public boolean mkdir() {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkWrite(path);
    }
    if (isInvalid()) {
        return false;
    }
    return fs.createDirectory(this);
}
```

**特点**：
- 只创建单级目录
- 如果父目录不存在，返回false

#### 1.6.5 mkdirs() - 创建多级目录

```java
public boolean mkdirs() {
    if (exists()) {
        return false;
    }
    if (mkdir()) {
        return true;
    }
    File canonFile = null;
    try {
        canonFile = getCanonicalFile();
    } catch (IOException e) {
        return false;
    }
    
    File parent = canonFile.getParentFile();
    return (parent != null && (parent.mkdirs() || parent.exists()) &&
            canonFile.mkdir());
}
```

**特点**：
- 创建多级目录
- 如果目录已存在，返回false

#### 1.6.6 renameTo(File dest) - 重命名文件

```java
public boolean renameTo(File dest) {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkWrite(path);
        security.checkWrite(dest.path);
    }
    if (dest == null) {
        throw new NullPointerException();
    }
    if (this.isInvalid() || dest.isInvalid()) {
        return false;
    }
    return fs.rename(this, dest);
}
```

**特点**：
- 可以用于重命名或移动文件
- 原子操作

#### 1.6.7 setLastModified(long time) - 设置最后修改时间

```java
public boolean setLastModified(long time) {
    if (time < 0) {
        throw new IllegalArgumentException("Negative time");
    }
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkWrite(path);
    }
    if (isInvalid()) {
        return false;
    }
    return fs.setLastModifiedTime(this, time);
}
```

#### 1.6.8 setReadOnly() - 设置为只读

```java
public boolean setReadOnly() {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkWrite(path);
    }
    if (isInvalid()) {
        return false;
    }
    return fs.setReadOnly(this);
}
```

#### 1.6.9 setWritable(boolean writable) - 设置可写权限

```java
public boolean setWritable(boolean writable) {
    return setWritable(writable, true);
}

public boolean setWritable(boolean writable, boolean ownerOnly) {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkWrite(path);
    }
    if (isInvalid()) {
        return false;
    }
    return fs.setPermission(this, FileSystem.ACCESS_WRITE, writable, ownerOnly);
}
```

#### 1.6.10 setReadable(boolean readable) - 设置可读权限

```java
public boolean setReadable(boolean readable) {
    return setReadable(readable, true);
}

public boolean setReadable(boolean readable, boolean ownerOnly) {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkWrite(path);
    }
    if (isInvalid()) {
        return false;
    }
    return fs.setPermission(this, FileSystem.ACCESS_READ, readable, ownerOnly);
}
```

#### 1.6.11 setExecutable(boolean executable) - 设置可执行权限

```java
public boolean setExecutable(boolean executable) {
    return setExecutable(executable, true);
}

public boolean setExecutable(boolean executable, boolean ownerOnly) {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkWrite(path);
    }
    if (isInvalid()) {
        return false;
    }
    return fs.setPermission(this, FileSystem.ACCESS_EXECUTE, executable, ownerOnly);
}
```

### 1.7 目录操作方法

#### 1.7.1 list() - 列出目录内容

```java
public String[] list() {
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkRead(path);
    }
    if (isInvalid()) {
        return null;
    }
    return fs.list(this);
}
```

#### 1.7.2 list(FilenameFilter filter) - 列出目录内容（带过滤）

```java
public String[] list(FilenameFilter filter) {
    String names[] = list();
    if ((names == null) || (filter == null)) {
        return names;
    }
    List<String> v = new ArrayList<>();
    for (int i = 0 ; i < names.length ; i++) {
        if (filter.accept(this, names[i])) {
            v.add(names[i]);
        }
    }
    return v.toArray(new String[v.size()]);
}
```

#### 1.7.3 listFiles() - 列出目录内容（返回File数组）

```java
public File[] listFiles() {
    String[] ss = list();
    if (ss == null) {
        return null;
    }
    int n = ss.length;
    File[] fs = new File[n];
    for (int i = 0; i < n; i++) {
        fs[i] = new File(ss[i], this.prefixLength);
    }
    return fs;
}
```

#### 1.7.4 listFiles(FileFilter filter) - 列出目录内容（带过滤）

```java
public File[] listFiles(FileFilter filter) {
    String ss[] = list();
    if (ss == null) {
        return null;
    }
    ArrayList<File> files = new ArrayList<>();
    for (String s : ss) {
        File f = new File(s, this.prefixLength);
        if ((filter == null) || filter.accept(f)) {
            files.add(f);
        }
    }
    return files.toArray(new File[files.size()]);
}
```

#### 1.7.5 listFiles(FilenameFilter filter) - 列出目录内容（带过滤）

```java
public File[] listFiles(FilenameFilter filter) {
    String ss[] = list();
    if (ss == null) {
        return null;
    }
    ArrayList<File> files = new ArrayList<>();
    for (String s : ss) {
        if ((filter == null) || filter.accept(this, s)) {
            files.add(new File(s, this.prefixLength));
        }
    }
    return files.toArray(new File[files.size()]);
}
```

### 1.8 其他方法

#### 1.8.1 compareTo(File pathname) - 比较路径

```java
public int compareTo(File pathname) {
    return fs.compare(this, pathname);
}
```

#### 1.8.2 equals(Object obj) - 判断相等

```java
public boolean equals(Object obj) {
    if ((obj != null) && (obj instanceof File)) {
        return compareTo((File)obj) == 0;
    }
    return false;
}
```

#### 1.8.3 hashCode() - 计算哈希值

```java
public int hashCode() {
    return fs.hashCode(this);
}
```

#### 1.8.4 toString() - 转换为字符串

```java
public String toString() {
    return getPath();
}
```

#### 1.8.5 toURI() - 转换为URI

```java
public URI toURI() {
    try {
        File f = getAbsoluteFile();
        String sp = f.getPath();
        if (f.isDirectory() && sp.charAt(sp.length() - 1) != separatorChar) {
            sp = sp + separatorChar;
        }
        return new URI("file", null, sp.replace(separatorChar, '/'), null, null);
    } catch (URISyntaxException x) {
        throw new Error(x);
    }
}
```

#### 1.8.6 toPath() - 转换为Path

```java
public Path toPath() {
    Path result = filePath;
    if (result == null) {
        result = FileSystems.getDefault().getPath(path);
        filePath = result;
    }
    return result;
}
```

## 二、RandomAccessFile详解

### 2.1 RandomAccessFile概述

**RandomAccessFile特点**：
- 支持随机读写：可以跳转到文件的任意位置
- 类似大字节数组：文件指针指向当前读写位置
- 支持读写模式：可以同时进行读写操作
- 实现DataInput和DataOutput接口

### 2.2 核心字段

```java
public class RandomAccessFile implements DataOutput, DataInput, Closeable {
    // 文件描述符
    private FileDescriptor fd;
    
    // 文件通道
    private FileChannel channel = null;
    
    // 是否可读写
    private boolean rw;
    
    // 文件路径
    private final String path;
    
    // 关闭锁
    private Object closeLock = new Object();
    
    // 关闭状态
    private volatile boolean closed = false;
    
    // 模式常量
    private static final int O_RDONLY = 1;
    private static final int O_RDWR =   2;
    private static final int O_SYNC =   4;
    private static final int O_DSYNC =  8;
}
```

### 2.3 构造方法

#### 2.3.1 通过文件名和模式构造

```java
public RandomAccessFile(String name, String mode) throws FileNotFoundException {
    this(name != null ? new File(name) : null, mode);
}
```

#### 2.3.2 通过File对象和模式构造

```java
public RandomAccessFile(File file, String mode) throws FileNotFoundException {
    String name = (file != null ? file.getPath() : null);
    int imode = -1;
    if (mode.equals("r")) {
        imode = O_RDONLY;
    } else if (mode.startsWith("rw")) {
        imode = O_RDWR;
        rw = true;
        if (mode.length() > 2) {
            if (mode.equals("rws")) {
                imode |= O_SYNC;
            } else if (mode.equals("rwd")) {
                imode |= O_DSYNC;
            } else {
                imode = -1;
            }
        }
    }
    
    if (imode < 0) {
        throw new IllegalArgumentException("Illegal mode \"" + mode + "\" must be one of \"r\", \"rw\", \"rws\", or \"rwd\"");
    }
    
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkRead(name);
        if (rw) {
            security.checkWrite(name);
        }
    }
    
    if (name == null) {
        throw new NullPointerException();
    }
    if (file.isInvalid()) {
        throw new FileNotFoundException("Invalid file path");
    }
    fd = new FileDescriptor();
    fd.attach(this);
    path = name;
    open(name, imode);
}
```

**模式说明**：
- **"r"**：只读模式
- **"rw"**：读写模式
- **"rws"**：读写模式，同步更新内容和元数据
- **"rwd"**：读写模式，同步更新内容

### 2.4 文件指针操作

#### 2.4.1 getFilePointer() - 获取文件指针位置

```java
public native long getFilePointer() throws IOException;
```

#### 2.4.2 seek(long pos) - 设置文件指针位置

```java
public native void seek(long pos) throws IOException;
```

**特点**：
- 可以跳转到文件的任意位置
- pos >= 0

#### 2.4.3 length() - 获取文件长度

```java
public native long length() throws IOException;
```

#### 2.4.4 setLength(long newLength) - 设置文件长度

```java
public native void setLength(long newLength) throws IOException;
```

**特点**：
- 如果newLength < 当前长度，截断文件
- 如果newLength > 当前长度，扩展文件

### 2.5 读取方法

#### 2.5.1 read() - 读取单个字节

```java
public int read() throws IOException {
    return read0();
}

private native int read0() throws IOException;
```

#### 2.5.2 read(byte b[]) - 读取字节数组

```java
public int read(byte b[]) throws IOException {
    return readBytes(b, 0, b.length);
}
```

#### 2.5.3 read(byte b[], int off, int len) - 读取指定范围

```java
public int read(byte b[], int off, int len) throws IOException {
    return readBytes(b, off, len);
}

private native int readBytes(byte b[], int off, int len) throws IOException;
```

#### 2.5.4 readFully(byte b[]) - 完全读取

```java
public final void readFully(byte b[]) throws IOException {
    readFully(b, 0, b.length);
}
```

#### 2.5.5 readFully(byte b[], int off, int len) - 完全读取指定范围

```java
public final void readFully(byte b[], int off, int len) throws IOException {
    int n = 0;
    while (n < len) {
        int count = this.read(b, off + n, len - n);
        if (count < 0) {
            throw new EOFException();
        }
        n += count;
    }
}
```

**特点**：必须读取指定数量的字节，否则抛出EOFException

#### 2.5.6 readBoolean() - 读取布尔值

```java
public final boolean readBoolean() throws IOException {
    int ch = this.read();
    if (ch < 0) {
        throw new EOFException();
    }
    return (ch != 0);
}
```

#### 2.5.7 readByte() - 读取字节

```java
public final byte readByte() throws IOException {
    int ch = this.read();
    if (ch < 0) {
        throw new EOFException();
    }
    return (byte)(ch);
}
```

#### 2.5.8 readUnsignedByte() - 读取无符号字节

```java
public final int readUnsignedByte() throws IOException {
    int ch = this.read();
    if (ch < 0) {
        throw new EOFException();
    }
    return ch;
}
```

#### 2.5.9 readShort() - 读取短整型

```java
public final short readShort() throws IOException {
    int ch1 = this.read();
    int ch2 = this.read();
    if ((ch1 | ch2) < 0) {
        throw new EOFException();
    }
    return (short)((ch1 << 8) + (ch2 << 0));
}
```

#### 2.5.10 readUnsignedShort() - 读取无符号短整型

```java
public final int readUnsignedShort() throws IOException {
    int ch1 = this.read();
    int ch2 = this.read();
    if ((ch1 | ch2) < 0) {
        throw new EOFException();
    }
    return (ch1 << 8) + (ch2 << 0);
}
```

#### 2.5.11 readChar() - 读取字符

```java
public final char readChar() throws IOException {
    int ch1 = this.read();
    int ch2 = this.read();
    if ((ch1 | ch2) < 0) {
        throw new EOFException();
    }
    return (char)((ch1 << 8) + (ch2 << 0));
}
```

#### 2.5.12 readInt() - 读取整型

```java
public final int readInt() throws IOException {
    int ch1 = this.read();
    int ch2 = this.read();
    int ch3 = this.read();
    int ch4 = this.read();
    if ((ch1 | ch2 | ch3 | ch4) < 0) {
        throw new EOFException();
    }
    return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));
}
```

#### 2.5.13 readLong() - 读取长整型

```java
public final long readLong() throws IOException {
    return ((long)(readInt()) << 32) + (readInt() & 0xFFFFFFFFL);
}
```

#### 2.5.14 readFloat() - 读取浮点数

```java
public final float readFloat() throws IOException {
    return Float.intBitsToFloat(readInt());
}
```

#### 2.5.15 readDouble() - 读取双精度浮点数

```java
public final double readDouble() throws IOException {
    return Double.longBitsToDouble(readLong());
}
```

#### 2.5.16 readLine() - 读取一行

```java
public final String readLine() throws IOException {
    StringBuffer input = new StringBuffer();
    int c = -1;
    boolean eol = false;
    
    while (!eol) {
        switch (c = read()) {
            case -1:
            case '\n':
                eol = true;
                break;
            case '\r':
                eol = true;
                long cur = getFilePointer();
                if ((read()) != '\n') {
                    seek(cur);
                }
                break;
            default:
                input.append((char)c);
                break;
        }
    }
    
    if ((c == -1) && (input.length() == 0)) {
        return null;
    }
    return input.toString();
}
```

**换行符处理**：
- Unix：\n
- Windows：\r\n
- Mac（旧版）：\r

#### 2.5.17 readUTF() - 读取UTF-8字符串

```java
public final String readUTF() throws IOException {
    return DataInputStream.readUTF(this);
}
```

### 2.6 写入方法

#### 2.6.1 write(int b) - 写入单个字节

```java
public void write(int b) throws IOException {
    write0(b);
}

private native void write0(int b) throws IOException;
```

#### 2.6.2 write(byte b[]) - 写入字节数组

```java
public void write(byte b[]) throws IOException {
    writeBytes(b, 0, b.length);
}
```

#### 2.6.3 write(byte b[], int off, int len) - 写入指定范围

```java
public void write(byte b[], int off, int len) throws IOException {
    writeBytes(b, off, len);
}

private native void writeBytes(byte b[], int off, int len) throws IOException;
```

#### 2.6.4 writeBoolean(boolean v) - 写入布尔值

```java
public final void writeBoolean(boolean v) throws IOException {
    write(v ? 1 : 0);
}
```

#### 2.6.5 writeByte(int v) - 写入字节

```java
public final void writeByte(int v) throws IOException {
    write(v);
}
```

#### 2.6.6 writeShort(int v) - 写入短整型

```java
public final void writeShort(int v) throws IOException {
    write((v >>> 8) & 0xFF);
    write((v >>> 0) & 0xFF);
}
```

#### 2.6.7 writeChar(int v) - 写入字符

```java
public final void writeChar(int v) throws IOException {
    write((v >>> 8) & 0xFF);
    write((v >>> 0) & 0xFF);
}
```

#### 2.6.8 writeInt(int v) - 写入整型

```java
public final void writeInt(int v) throws IOException {
    write((v >>> 24) & 0xFF);
    write((v >>> 16) & 0xFF);
    write((v >>>  8) & 0xFF);
    write((v >>>  0) & 0xFF);
}
```

#### 2.6.9 writeLong(long v) - 写入长整型

```java
public final void writeLong(long v) throws IOException {
    write((int)(v >>> 56) & 0xFF);
    write((int)(v >>> 48) & 0xFF);
    write((int)(v >>> 40) & 0xFF);
    write((int)(v >>> 32) & 0xFF);
    write((int)(v >>> 24) & 0xFF);
    write((int)(v >>> 16) & 0xFF);
    write((int)(v >>>  8) & 0xFF);
    write((int)(v >>>  0) & 0xFF);
}
```

#### 2.6.10 writeFloat(float v) - 写入浮点数

```java
public final void writeFloat(float v) throws IOException {
    writeInt(Float.floatToIntBits(v));
}
```

#### 2.6.11 writeDouble(double v) - 写入双精度浮点数

```java
public final void writeDouble(double v) throws IOException {
    writeLong(Double.doubleToLongBits(v));
}
```

#### 2.6.12 writeBytes(String s) - 写入字符串（按字节）

```java
public final void writeBytes(String s) throws IOException {
    int len = s.length();
    byte[] b = new byte[len];
    s.getBytes(0, len, b, 0);
    writeBytes(b, 0, len);
}
```

#### 2.6.13 writeChars(String s) - 写入字符串（按字符）

```java
public final void writeChars(String s) throws IOException {
    int clen = s.length();
    int blen = 2 * clen;
    byte[] b = new byte[blen];
    char[] c = new char[clen];
    s.getChars(0, clen, c, 0);
    for (int i = 0, j = 0; i < clen; i++) {
        b[j++] = (byte)(c[i] >>> 8);
        b[j++] = (byte)(c[i] >>> 0);
    }
    writeBytes(b, 0, blen);
}
```

#### 2.6.14 writeUTF(String str) - 写入UTF-8字符串

```java
public final void writeUTF(String str) throws IOException {
    DataOutputStream.writeUTF(str, this);
}
```

### 2.7 其他方法

#### 2.7.1 getChannel() - 获取文件通道

```java
public final FileChannel getChannel() {
    synchronized (this) {
        if (channel == null) {
            channel = FileChannelImpl.open(fd, path, true, rw, this);
        }
        return channel;
    }
}
```

#### 2.7.2 close() - 关闭文件

```java
public void close() throws IOException {
    synchronized (closeLock) {
        if (closed) {
            return;
        }
        closed = true;
    }
    
    if (channel != null) {
        channel.close();
    }
    
    fd.closeAll(new Closeable() {
        public void close() throws IOException {
            close0();
        }
    });
}

private native void close0() throws IOException;
```

## 三、使用示例

### 3.1 File类使用示例

```java
// 创建文件
File file = new File("test.txt");
if (!file.exists()) {
    file.createNewFile();
}

// 创建目录
File dir = new File("testdir");
if (!dir.exists()) {
    dir.mkdirs();
}

// 列出目录内容
File[] files = dir.listFiles();
for (File f : files) {
    System.out.println(f.getName());
}

// 文件过滤
File[] txtFiles = dir.listFiles(new FilenameFilter() {
    @Override
    public boolean accept(File dir, String name) {
        return name.endsWith(".txt");
    }
});
```

### 3.2 RandomAccessFile使用示例

```java
// 写入数据
RandomAccessFile raf = new RandomAccessFile("test.dat", "rw");
raf.writeInt(123);
raf.writeDouble(99.99);
raf.writeUTF("Hello");
raf.close();

// 读取数据
RandomAccessFile raf = new RandomAccessFile("test.dat", "r");
int value = raf.readInt();
double price = raf.readDouble();
String text = raf.readUTF();
raf.close();

// 随机访问
RandomAccessFile raf = new RandomAccessFile("test.dat", "rw");
raf.seek(100);  // 跳转到第100个字节
raf.write(65);   // 写入数据
raf.close();
```

## 四、最佳实践

### 4.1 使用try-with-resources

```java
// 推荐
try (RandomAccessFile raf = new RandomAccessFile("test.dat", "rw")) {
    raf.writeInt(123);
}
```

### 4.2 检查文件是否存在

```java
File file = new File("test.txt");
if (file.exists()) {
    // 处理文件
}
```

### 4.3 使用规范路径

```java
File file = new File("../test.txt");
File canonicalFile = file.getCanonicalFile();
```

### 4.4 使用文件过滤器

```java
File[] files = dir.listFiles(new FilenameFilter() {
    @Override
    public boolean accept(File dir, String name) {
        return name.endsWith(".txt");
    }
});
```

## 五、相关源码位置

| 类名 | 源码路径 |
|------|----------|
| File | src/main/jdk8/java/io/File.java |
| RandomAccessFile | src/main/jdk8/java/io/RandomAccessFile.java |
| FileDescriptor | src/main/jdk8/java/io/FileDescriptor.java |
| FilenameFilter | src/main/jdk8/java/io/FilenameFilter.java |
| FileFilter | src/main/jdk8/java/io/FileFilter.java |
