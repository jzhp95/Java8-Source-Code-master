# Java集合框架体系源码深度解析

## 一、集合框架总览

### 1.1 集合框架概述

#### 1.1.1 集合框架的引入背景

在Java 1.2之前,Java只提供了Vector、Hashtable等少数集合类,这些类存在明显的局限性:Vector和Hashtable是线程安全的,但同步开销大;没有统一的接口,使用不便;缺乏泛型支持,类型不安全。

Java 1.2引入了集合框架(Collections Framework),它是一套用于表示和操作集合的统一架构。集合框架提供了高性能的数据结构、统一的接口和灵活的算法,大大简化了集合操作。

集合框架的核心优势包括:

**统一接口**: 提供了List、Set、Map等核心接口,定义了集合的基本操作。

**高性能实现**: 提供了ArrayList、HashMap等高性能实现,针对不同场景优化。

**算法支持**: 提供了Collections工具类,包含排序、查找、填充等常用算法。

**泛型支持**: Java 5引入泛型后,集合框架支持类型安全。

#### 1.1.2 集合框架的核心接口

```
Collection (接口)
    ├─ List (接口) - 有序集合,允许重复
    │   ├─ ArrayList - 数组实现,随机访问快
    │   ├─ LinkedList - 链表实现,插入删除快
    │   ├─ Vector - 线程安全的数组实现(已过时)
    │   └─ Stack - 栈实现(已过时)
    │
    ├─ Set (接口) - 无序集合,不允许重复
    │   ├─ HashSet - 哈希表实现,查找快
    │   ├─ LinkedHashSet - 保持插入顺序的HashSet
    │   ├─ TreeSet - 基于TreeMap,有序
    │   └─ EnumSet - 枚举类型专用Set
    │
    └─ Queue (接口) - 队列,FIFO
        ├─ PriorityQueue - 优先级队列
        ├─ LinkedList - 实现了Deque
        └─ Deque (接口) - 双端队列
            ├─ ArrayDeque - 数组实现
            ├─ LinkedList - 链表实现
            └─ LinkedBlockingDeque - 并发实现

Map (接口) - 键值对映射
    ├─ HashMap - 哈希表实现,查找快
    ├─ LinkedHashMap - 保持插入顺序的HashMap
    ├─ TreeMap - 红黑树实现,有序
    ├─ Hashtable - 线程安全的HashMap(已过时)
    ├─ WeakHashMap - 弱引用Map
    ├─ IdentityHashMap - 引用相等而非对象相等
    └─ EnumMap - 枚举类型专用Map
```

### 1.2 集合框架设计原则

#### 1.2.1 接口与实现分离

集合框架采用接口与实现分离的设计原则,接口定义了集合的行为,实现提供了具体的算法和数据结构。

```java
// 接口定义行为
public interface List<E> extends Collection<E> {
    boolean add(E e);
    E get(int index);
    E remove(int index);
}

// 实现提供具体算法
public class ArrayList<E> extends AbstractList<E> implements List<E> {
    private Object[] elementData;
    
    public boolean add(E e) {
        ensureCapacityInternal(size + 1);
        elementData[size++] = e;
        return true;
    }
    
    public E get(int index) {
        rangeCheck(index);
        return elementData(index);
    }
}
```

这种设计的优点是:

**灵活性**: 可以根据需求选择不同的实现,如ArrayList或LinkedList。

**可替换性**: 代码依赖于接口,可以轻松替换实现。

**扩展性**: 可以创建自定义实现,同时保持接口兼容性。

#### 1.2.2 迭代器模式

集合框架使用迭代器模式来遍历集合元素,迭代器提供了统一的遍历方式。

```java
public interface Iterator<E> {
    boolean hasNext();
    E next();
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }
    default void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}
```

**迭代器的特点:**

1. **统一遍历**: 所有集合都可以使用Iterator遍历。

2. **安全删除**: 可以在遍历过程中安全删除元素。

3. **轻量级**: 迭代器对象很小,不占用太多内存。

**使用示例:**

```java
List<String> list = new ArrayList<>();
list.add("A");
list.add("B");
list.add("C");

// 使用Iterator遍历
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String element = iterator.next();
    System.out.println(element);
}

// 使用for-each语法糖
for (String element : list) {
    System.out.println(element);
}
```

#### 1.2.3 泛型支持

Java 5引入泛型后,集合框架支持类型安全,避免了类型转换和ClassCastException。

```java
// 泛型List
List<String> list = new ArrayList<>();
list.add("Hello");
String s = list.get(0); // 不需要类型转换

// 编译时类型检查
list.add(123); // 编译错误
```

**泛型的优势:**

1. **类型安全**: 编译时检查类型,避免运行时错误。

2. **消除类型转换**: 不需要手动类型转换。

3. **代码可读性**: 泛型参数明确表示集合中元素的类型。

### 1.3 核心接口详解

#### 1.3.1 Collection接口

Collection是集合框架的根接口,定义了所有集合共有的操作。

```java
public interface Collection<E> extends Iterable<E> {
    // 查询操作
    int size();
    boolean isEmpty();
    boolean contains(Object o);
    Iterator<E> iterator();
    Object[] toArray();
    <T> T[] toArray(T[] a);
    
    // 修改操作
    boolean add(E e);
    boolean remove(Object o);
    boolean containsAll(Collection<?> c);
    boolean addAll(Collection<? extends E> c);
    boolean removeAll(Collection<?> c);
    boolean retainAll(Collection<?> c);
    void clear();
    
    // 批量操作
    default boolean removeIf(Predicate<? super E> filter) {
        Objects.requireNonNull(filter);
        boolean removed = false;
        final Iterator<E> each = iterator();
        while (each.hasNext()) {
            if (filter.test(each.next())) {
                each.remove();
                removed = true;
            }
        }
        return removed;
    }
    
    // 比较和哈希
    boolean equals(Object o);
    int hashCode();
    
    // 流操作
    default Spliterator<E> spliterator() {
        return Spliterators.spliterator(this, 0);
    }
    
    default Stream<E> stream() {
        return StreamSupport.stream(spliterator(), false);
    }
    
    default Stream<E> parallelStream() {
        return StreamSupport.stream(spliterator(), true);
    }
}
```

**Collection的核心方法分类:**

1. **查询操作**: size、isEmpty、contains、iterator等
2. **修改操作**: add、remove、clear等
3. **批量操作**: addAll、removeAll、retainAll等
4. **流操作**: stream、parallelStream等

#### 1.3.2 List接口

List是有序集合,允许重复元素,支持基于索引的访问。

```java
public interface List<E> extends Collection<E> {
    // 位置访问操作
    E get(int index);
    E set(int index, E element);
    void add(int index, E element);
    E remove(int index);
    
    // 查询操作
    int indexOf(Object o);
    int lastIndexOf(Object o);
    List<E> subList(int fromIndex, int toIndex);
    
    // 列表迭代器
    ListIterator<E> listIterator();
    ListIterator<E> listIterator(int index);
    
    // 批量操作
    default void sort(Comparator<? super E> c) {
        Object[] a = this.toArray();
        Arrays.sort(a, (Comparator) c);
        ListIterator<E> i = this.listIterator();
        for (Object e : a) {
            i.next();
            i.set((E) e);
        }
    }
    
    default void replaceAll(UnaryOperator<E> operator) {
        Objects.requireNonNull(operator);
        final ListIterator<E> li = this.listIterator();
        while (li.hasNext()) {
            li.set(operator.apply(li.next()));
        }
    }
}
```

**List的特点:**

1. **有序性**: 元素按照插入顺序存储。
2. **索引访问**: 支持基于索引的随机访问。
3. **允许重复**: 可以包含重复元素。

#### 1.3.3 Set接口

Set是不包含重复元素的集合,不保证元素的顺序。

```java
public interface Set<E> extends Collection<E> {
    // 继承Collection的所有方法
    // 没有新增方法,只是语义上的约束
    
    // 默认实现
    @Override
    default Spliterator<E> spliterator() {
        return Spliterators.spliterator(this, Spliterator.DISTINCT);
    }
}
```

**Set的特点:**

1. **唯一性**: 不包含重复元素。
2. **无序性**: 不保证元素的顺序(除了LinkedHashSet、TreeSet等)。
3. **查找效率**: 基于哈希的Set查找效率高。

#### 1.3.4 Map接口

Map存储键值对映射,键不能重复,值可以重复。

```java
public interface Map<K,V> {
    // 基本操作
    int size();
    boolean isEmpty();
    boolean containsKey(Object key);
    boolean containsValue(Object value);
    V get(Object key);
    
    // 修改操作
    V put(K key, V value);
    V remove(Object key);
    void putAll(Map<? extends K,? extends V> m);
    void clear();
    
    // 视图操作
    Set<K> keySet();
    Collection<V> values();
    Set<Map.Entry<K,V>> entrySet();
    
    // 接口Entry
    interface Entry<K,V> {
        K getKey();
        V getValue();
        V setValue(V value);
        boolean equals(Object o);
        int hashCode();
    }
    
    // 默认方法
    default V getOrDefault(Object key, V defaultValue) {
        V v;
        return (((v = get(key)) != null) || containsKey(key))
            ? v
            : defaultValue;
    }
    
    default V putIfAbsent(K key, V value) {
        V v = get(key);
        if (v == null) {
            v = put(key, value);
        }
        return v;
    }
    
    default boolean remove(Object key, Object value) {
        Object curValue = get(key);
        if (!Objects.equals(curValue, value) ||
            (curValue == null && !containsKey(key))) {
            return false;
        }
        remove(key);
        return true;
    }
    
    default boolean replace(K key, V oldValue, V newValue) {
        Object curValue = get(key);
        if (!Objects.equals(curValue, oldValue) ||
            (curValue == null && !containsKey(key))) {
            return false;
        }
        put(key, newValue);
        return true;
    }
    
    default V replace(K key, V value) {
        V curValue;
        if (((curValue = get(key)) != null) || containsKey(key)) {
            curValue = put(key, value);
        }
        return curValue;
    }
    
    default V computeIfAbsent(K key,
                             Function<? super K,? extends V> mappingFunction) {
        Objects.requireNonNull(mappingFunction);
        V v, newValue;
        return ((v = get(key)) == null &&
                (newValue = mappingFunction.apply(key)) != null &&
                (v = putIfAbsent(key, newValue)) == null) ? newValue : v;
    }
    
    default V computeIfPresent(K key,
                              BiFunction<? super K,? super V,? extends V> remappingFunction) {
        Objects.requireNonNull(remappingFunction);
        V oldValue;
        if ((oldValue = get(key)) != null) {
            V newValue = remappingFunction.apply(key, oldValue);
            if (newValue != null) {
                put(key, newValue);
                return newValue;
            } else {
                remove(key);
                return null;
            }
        } else {
            return null;
        }
    }
    
    default V compute(K key,
                     BiFunction<? super K,? super V,? extends V> remappingFunction) {
        Objects.requireNonNull(remappingFunction);
        V oldValue = get(key);
        V newValue = remappingFunction.apply(key, oldValue);
        if (newValue == null) {
            if (oldValue != null || containsKey(key)) {
                remove(key);
                return null;
            } else {
                return null;
            }
        } else {
            put(key, newValue);
            return newValue;
        }
    }
    
    default V merge(K key, V value,
                   BiFunction<? super V,? super V,? extends V> remappingFunction) {
        Objects.requireNonNull(remappingFunction);
        Objects.requireNonNull(value);
        V oldValue = get(key);
        V newValue = (oldValue == null) ? value :
                      remappingFunction.apply(oldValue, value);
        if (newValue == null) {
            remove(key);
        } else {
            put(key, newValue);
        }
        return newValue;
    }
}
```

**Map的特点:**

1. **键值对**: 存储键到值的映射。
2. **键唯一**: 键不能重复。
3. **值可重复**: 值可以重复。

### 1.4 集合框架性能考量

#### 1.4.1 时间复杂度对比

| 操作 | ArrayList | LinkedList | HashSet | TreeSet | HashMap | TreeMap |
|------|-----------|------------|---------|---------|---------|---------|
| add | O(1) | O(1) | O(1) | O(log n) | O(1) | O(log n) |
| get | O(1) | O(n) | O(1) | O(log n) | O(1) | O(log n) |
| remove | O(n) | O(1) | O(1) | O(log n) | O(1) | O(log n) |
| contains | O(n) | O(n) | O(1) | O(log n) | O(1) | O(log n) |

**说明:**

- ArrayList的add是O(1),但可能需要扩容
- LinkedList的remove是O(1)当已知节点位置时
- HashSet的查找是O(1),但可能发生哈希冲突
- TreeSet的所有操作都是O(log n),因为基于红黑树

#### 1.4.2 内存占用对比

| 集合类型 | 内存占用 | 说明 |
|---------|---------|------|
| ArrayList | 较小 | 连续内存,无额外指针 |
| LinkedList | 较大 | 每个节点需要额外指针 |
| HashSet | 中等 | 需要存储哈希表和链表 |
| TreeSet | 较大 | 红黑树需要额外指针 |
| HashMap | 中等 | 需要存储哈希表和链表/树 |
| TreeMap | 较大 | 红黑树需要额外指针 |

#### 1.4.3 选择集合类型的考虑因素

**1. 访问模式:**

- 随机访问: 使用ArrayList
- 频繁插入删除: 使用LinkedList
- 快速查找: 使用HashSet/HashMap
- 需要排序: 使用TreeSet/TreeMap

**2. 内存限制:**

- 内存敏感: 使用ArrayList
- 内存充足: 可以使用LinkedList

**3. 线程安全:**

- 单线程: 使用非线程安全集合
- 多线程: 使用并发集合或同步包装

**4. 顺序要求:**

- 需要插入顺序: 使用LinkedHashSet/LinkedHashMap
- 需要排序: 使用TreeSet/TreeMap
- 不需要顺序: 使用HashSet/HashMap

### 1.5 集合框架最佳实践

#### 1.5.1 选择合适的集合类型

```java
// 场景1: 需要快速随机访问
List<String> list = new ArrayList<>();

// 场景2: 需要频繁插入删除
Deque<String> deque = new LinkedList<>();

// 场景3: 需要快速查找
Set<String> set = new HashSet<>();

// 场景4: 需要保持插入顺序
Set<String> orderedSet = new LinkedHashSet<>();

// 场景5: 需要排序
Set<String> sortedSet = new TreeSet<>();

// 场景6: 需要键值映射
Map<String, Integer> map = new HashMap<>();

// 场景7: 需要保持插入顺序
Map<String, Integer> orderedMap = new LinkedHashMap<>();

// 场景8: 需要按键排序
Map<String, Integer> sortedMap = new TreeMap<>();
```

#### 1.5.2 避免常见错误

**错误1: 使用Vector/Hashtable**

```java
// 错误示例: 使用过时的Vector
Vector<String> vector = new Vector<>();

// 正确示例: 使用ArrayList
List<String> list = new ArrayList<>();

// 如果需要线程安全
List<String> syncList = Collections.synchronizedList(new ArrayList<>());
```

**错误2: 使用Stack**

```java
// 错误示例: 使用过时的Stack
Stack<String> stack = new Stack<>();

// 正确示例: 使用Deque
Deque<String> deque = new ArrayDeque<>();
```

**错误3: 遍历时修改集合**

```java
// 错误示例: 使用for-each删除元素
List<String> list = new ArrayList<>();
list.add("A");
list.add("B");
list.add("C");

for (String s : list) {
    if (s.equals("B")) {
        list.remove(s); // ConcurrentModificationException
    }
}

// 正确示例1: 使用Iterator
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String s = iterator.next();
    if (s.equals("B")) {
        iterator.remove();
    }
}

// 正确示例2: 使用removeIf
list.removeIf(s -> s.equals("B"));
```

**错误4: 使用==比较集合元素**

```java
// 错误示例: 使用==比较
List<String> list = new ArrayList<>();
list.add(new String("Hello"));

if (list.get(0) == "Hello") { // 可能返回false
    // ...
}

// 正确示例: 使用equals
if (list.get(0).equals("Hello")) { // 正确
    // ...
}
```

#### 1.5.3 性能优化建议

**1. 预估集合大小**

```java
// 错误示例: 不指定初始容量
List<String> list = new ArrayList<>();

// 正确示例: 指定初始容量
List<String> list = new ArrayList<>(1000);
```

**2. 使用合适的集合类型**

```java
// 场景1: 只需要遍历,不需要索引
for (String s : list) {
    // ...
}

// 场景2: 需要频繁查找
Set<String> set = new HashSet<>(list);
if (set.contains("target")) {
    // ...
}
```

**3. 使用批量操作**

```java
// 错误示例: 逐个添加
List<String> list = new ArrayList<>();
for (String s : sourceList) {
    list.add(s);
}

// 正确示例: 批量添加
List<String> list = new ArrayList<>(sourceList);
```

### 1.6 小结

集合框架是Java中最常用的API之一,理解其设计理念和实现原理对于编写高效、正确的代码至关重要。

**核心要点总结:**

第一,**统一接口**: List、Set、Map等核心接口定义了集合的基本操作。

第二,**接口与实现分离**: 接口定义行为,实现提供具体算法和数据结构。

第三,**迭代器模式**: 提供了统一的遍历方式。

第四,**泛型支持**: 支持类型安全,避免类型转换。

第五,**性能考量**: 不同集合类型有不同的时间复杂度和内存占用。

第六,**最佳实践**: 选择合适的集合类型、避免常见错误、优化性能。

后续文档将深入讲解各个集合类型的源码实现。
