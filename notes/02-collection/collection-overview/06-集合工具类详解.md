# Java集合框架体系源码深度解析——集合工具类详解

## 六、集合工具类详解

### 6.1 Collections类深度解析

#### 6.1.1 Collections概述

Collections是Java集合框架的工具类,它提供了大量静态方法来操作和返回集合。Collections类不能被实例化,所有方法都是静态的。

**Collections的核心功能:**

1. **排序**: 提供多种排序方法。

2. **查找**: 提供二分查找等方法。

3. **填充**: 提供填充集合的方法。

4. **同步**: 提供线程安全的包装方法。

5. **不可变**: 提供创建不可变集合的方法。

6. **空集合**: 提供创建空集合的方法。

```java
public class Collections {
    // 私有构造方法,防止实例化
    private Collections() {
    }
    
    // 空集合
    public static final List EMPTY_LIST = new EmptyList<>();
    public static final Set EMPTY_SET = new EmptySet<>();
    public static final Map EMPTY_MAP = new EmptyMap<>();
}
```

#### 6.1.2 排序方法

```java
// 对List进行排序
public static <T extends Comparable<? super T>> void sort(List<T> list) {
    Object[] a = list.toArray();
    Arrays.sort(a);
    ListIterator<T> i = list.listIterator();
    for (int j=0; j<a.length; j++) {
        i.next();
        i.set((T)a[j]);
    }
}

// 使用指定的Comparator对List进行排序
public static <T> void sort(List<T> list, Comparator<? super T> c) {
    Object[] a = list.toArray();
    Arrays.sort(a, (Comparator)c);
    ListIterator<T> i = list.listIterator();
    for (int j=0; j<a.length; j++) {
        i.next();
        i.set((T)a[j]);
    }
}

// 反转List
public static void reverse(List<?> list) {
    int size = list.size();
    if (size < REVERSE_THRESHOLD || list instanceof RandomAccess) {
        for (int i=0, mid=size>>1, j=size-1; i<mid; i++, j--)
            swap(list, i, j);
    } else {
        ListIterator fwd = list.listIterator();
        ListIterator rev = list.listIterator(size);
        for (int i=0, mid=list.size()>>1; i<mid; i++) {
            Object tmp = fwd.next();
            fwd.set(rev.previous());
            rev.set(tmp);
        }
    }
}

// 随机打乱List
public static void shuffle(List<?> list) {
    Random rnd = r;
    if (rnd == null)
        r = rnd = new Random();
    shuffle(list, rnd);
}

// 使用指定的Random随机打乱List
public static void shuffle(List<?> list, Random rnd) {
    int size = list.size();
    if (size < SHUFFLE_THRESHOLD || list instanceof RandomAccess) {
        for (int i=size; i>1; i--)
            swap(list, i-1, rnd.nextInt(i));
    } else {
        Object arr[] = list.toArray();
        for (int i=size; i>1; i--)
            swap(arr, i-1, rnd.nextInt(i));
        ListIterator it = list.listIterator();
        for (int i=0; i<arr.length; i++) {
            it.next();
            it.set(arr[i]);
        }
    }
}

// 交换两个元素
private static void swap(List<?> list, int i, int j) {
    final List l = list;
    l.set(i, l.set(j, l.get(i)));
}
```

**排序方法的时间复杂度:**

- sort: O(n log n) - 使用TimSort算法
- reverse: O(n) - 需要遍历所有元素
- shuffle: O(n) - 需要遍历所有元素

#### 6.1.3 查找方法

```java
// 使用二分查找
public static <T> int binarySearch(List<? extends Comparable<? super T>> list, T key) {
    if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)
        return Collections.indexedBinarySearch(list, key);
    else
        return Collections.iteratorBinarySearch(list, key);
}

// 使用RandomAccess接口的二分查找
private static <T> int indexedBinarySearch(List<? extends Comparable<? super T>> list, T key) {
    int low = 0;
    int high = list.size()-1;
    
    while (low <= high) {
        int mid = (low + high) >>> 1;
        Comparable<? super T> midVal = list.get(mid);
        int cmp = midVal.compareTo(key);
        
        if (cmp < 0)
            low = mid + 1;
        else if (cmp > 0)
            high = mid - 1;
        else
            return mid;
    }
    return -(low + 1);
}

// 使用Iterator的二分查找
private static <T> int iteratorBinarySearch(List<? extends Comparable<? super T>> list, T key) {
    int low = 0;
    int high = list.size()-1;
    
    ListIterator<? extends Comparable<? super T>> i = list.listIterator();
    while (low <= high) {
        int mid = (low + high) >>> 1;
        Comparable<? super T> midVal = get(i, mid);
        int cmp = midVal.compareTo(key);
        
        if (cmp < 0)
            low = mid + 1;
        else if (cmp > 0)
            high = mid - 1;
        else
            return mid;
    }
    return -(low + 1);
}

// 查找最大元素
public static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll) {
    Iterator<? extends T> i = coll.iterator();
    T candidate = i.next();
    
    while (i.hasNext()) {
        T next = i.next();
        if (next.compareTo(candidate) > 0)
            candidate = next;
    }
    return candidate;
}

// 使用指定的Comparator查找最大元素
public static <T> T max(Collection<? extends T> coll, Comparator<? super T> comp) {
    if (comp==null)
        throw new NullPointerException();
    
    Iterator<? extends T> i = coll.iterator();
    T candidate = i.next();
    
    while (i.hasNext()) {
        T next = i.next();
        if (comp.compare(next, candidate) > 0)
            candidate = next;
    }
    return candidate;
}

// 查找最小元素
public static <T extends Object & Comparable<? super T>> T min(Collection<? extends T> coll) {
    Iterator<? extends T> i = coll.iterator();
    T candidate = i.next();
    
    while (i.hasNext()) {
        T next = i.next();
        if (next.compareTo(candidate) < 0)
            candidate = next;
    }
    return candidate;
}

// 使用指定的Comparator查找最小元素
public static <T> T min(Collection<? extends T> coll, Comparator<? super T> comp) {
    if (comp==null)
        throw new NullPointerException();
    
    Iterator<? extends T> i = coll.iterator();
    T candidate = i.next();
    
    while (i.hasNext()) {
        T next = i.next();
        if (comp.compare(next, candidate) < 0)
            candidate = next;
    }
    return candidate;
}
```

**查找方法的时间复杂度:**

- binarySearch: O(log n) - 二分查找
- max/min: O(n) - 需要遍历所有元素

#### 6.1.4 填充方法

```java
// 使用指定元素填充List
public static <T> void fill(List<? super T> list, T obj) {
    int size = list.size();
    if (size < FILL_THRESHOLD || list instanceof RandomAccess) {
        for (int i=0; i<size; i++)
            list.set(i, obj);
    } else {
        ListIterator<? super T> itr = list.listIterator();
        for (int i=0; i<size; i++) {
            itr.next();
            itr.set(obj);
        }
    }
}

// 复制元素
public static <T> void copy(List<? super T> dest, List<? extends T> src) {
    int srcSize = src.size();
    if (srcSize > dest.size())
        throw new IllegalArgumentException("Source does not fit in dest");
    
    if (srcSize < COPY_THRESHOLD ||
        (src instanceof RandomAccess && dest instanceof RandomAccess)) {
        for (int i=0; i<srcSize; i++)
            dest.set(i, src.get(i));
    } else {
        ListIterator<? super T> di=dest.listIterator();
        ListIterator<? extends T> si=src.listIterator();
        for (int i=0; i<srcSize; i++) {
            di.next();
            di.set(si.next());
        }
    }
}

// 替换所有元素
public static <T> boolean replaceAll(List<T> list, T oldVal, T newVal) {
    boolean result = false;
    int size = list.size();
    if (size < REPLACEALL_THRESHOLD || list instanceof RandomAccess) {
        for (int i=0; i<size; i++) {
            if (oldVal.equals(list.get(i))) {
                list.set(i, newVal);
                result = true;
            }
        }
    } else {
        ListIterator<T> itr=list.listIterator();
        for (int i=0; i<size; i++) {
            if (oldVal.equals(itr.next())) {
                itr.set(newVal);
                result = true;
            }
        }
    }
    return result;
}
```

#### 6.1.5 同步方法

```java
// 返回线程安全的List
public static <T> List<T> synchronizedList(List<T> list) {
    return (list instanceof RandomAccess ?
            new SynchronizedRandomAccessList<>(list) :
            new SynchronizedList<>(list));
}

// 返回线程安全的Set
public static <T> Set<T> synchronizedSet(Set<T> s) {
    return new SynchronizedSet<>(s);
}

// 返回线程安全的Map
public static <K,V> Map<K,V> synchronizedMap(Map<K,V> m) {
    return new SynchronizedMap<>(m);
}

// SynchronizedList实现
static class SynchronizedList<E>
    extends SynchronizedCollection<E>
    implements List<E> {
    
    private static final long serialVersionUID = -775409037296297604L;
    
    final List<E> list;
    
    SynchronizedList(List<E> list) {
        super(list);
        this.list = list;
    }
    
    public E get(int index) {
        synchronized (mutex) {return list.get(index);}
    }
    
    public E set(int index, E element) {
        synchronized (mutex) {return list.set(index, element);}
    }
    
    public void add(int index, E element) {
        synchronized (mutex) {list.add(index, element);}
    }
    
    public E remove(int index) {
        synchronized (mutex) {return list.remove(index);}
    }
    
    public int indexOf(Object o) {
        synchronized (mutex) {return list.indexOf(o);}
    }
    
    public int lastIndexOf(Object o) {
        synchronized (mutex) {return list.lastIndexOf(o);}
    }
    
    public boolean addAll(int index, Collection<? extends E> c) {
        synchronized (mutex) {return list.addAll(index, c);}
    }
    
    public List<E> subList(int fromIndex, int toIndex) {
        synchronized (mutex) {
            return new SynchronizedSubList<>(list, fromIndex, toIndex, mutex);
        }
    }
    
    public ListIterator<E> listIterator() {
        return list.listIterator();
    }
    
    public ListIterator<E> listIterator(int index) {
        return list.listIterator(index);
    }
}
```

**同步方法的注意事项:**

1. **性能开销**: 同步方法会带来性能开销。

2. **迭代器不安全**: 返回的迭代器不是线程安全的,需要手动同步。

3. **复合操作不原子**: 复合操作(如检查再操作)不是原子的,需要额外同步。

#### 6.1.6 不可变方法

```java
// 返回不可变的List
public static <T> List<T> unmodifiableList(List<? extends T> list) {
    return (list instanceof RandomAccess ?
            new UnmodifiableRandomAccessList<>(list) :
            new UnmodifiableList<>(list));
}

// 返回不可变的Set
public static <T> Set<T> unmodifiableSet(Set<? extends T> s) {
    return new UnmodifiableSet<>(s);
}

// 返回不可变的Map
public static <K,V> Map<K,V> unmodifiableMap(Map<? extends K,? extends V> m) {
    return new UnmodifiableMap<>(m);
}

// UnmodifiableList实现
static class UnmodifiableList<E> extends UnmodifiableCollection<E>
                                  implements List<E> {
    private static final long serialVersionUID = -283967356065247728L;
    final List<? extends E> list;
    
    UnmodifiableList(List<? extends E> list) {
        super(list);
        this.list = list;
    }
    
    public boolean equals(Object o) {return o == this || list.equals(o);}
    public int hashCode() {return list.hashCode();}
    
    public E get(int index) {return list.get(index);}
    public E set(int index, E element) {
        throw new UnsupportedOperationException();
    }
    public void add(int index, E element) {
        throw new UnsupportedOperationException();
    }
    public E remove(int index) {
        throw new UnsupportedOperationException();
    }
    public int indexOf(Object o) {return list.indexOf(o);}
    public int lastIndexOf(Object o) {return list.lastIndexOf(o);}
    public boolean addAll(int index, Collection<? extends E> c) {
        throw new UnsupportedOperationException();
    }
    public ListIterator<E> listIterator()   {return listIterator(0);}
    public ListIterator<E> listIterator(final int index) {
        return new ListIterator<E>() {
            private final ListIterator<? extends E> i
                = list.listIterator(index);
            
            public boolean hasNext()     {return i.hasNext();}
            public E next()             {return i.next();}
            public boolean hasPrevious() {return i.hasPrevious();}
            public E previous()         {return i.previous();}
            public int nextIndex()       {return i.nextIndex();}
            public int previousIndex()   {return i.previousIndex();}
            public void remove() {
                throw new UnsupportedOperationException();
            }
            public void set(E e) {
                throw new UnsupportedOperationException();
            }
            public void add(E e) {
                throw new UnsupportedOperationException();
            }
        };
    }
    
    public List<E> subList(int fromIndex, int toIndex) {
        return new UnmodifiableSubList<>(list, fromIndex, toIndex);
    }
}
```

#### 6.1.7 空集合方法

```java
// 返回空的List
@SuppressWarnings("unchecked")
public static final <T> List<T> emptyList() {
    return (List<T>) EMPTY_LIST;
}

// 返回空的Set
@SuppressWarnings("unchecked")
public static final <T> Set<T> emptySet() {
    return (Set<T>) EMPTY_SET;
}

// 返回空的Map
@SuppressWarnings("unchecked")
public static final <K,V> Map<K,V> emptyMap() {
    return (Map<K,V>) EMPTY_MAP;
}

// 返回指定类型的空List
public static <T> List<T> emptyList() {
    return new EmptyList<>();
}

// 返回指定类型的空Set
public static <T> Set<T> emptySet() {
    return new EmptySet<>();
}

// 返回指定类型的空Map
public static <K,V> Map<K,V> emptyMap() {
    return new EmptyMap<>();
}
```

### 6.2 Arrays类深度解析

#### 6.2.1 Arrays概述

Arrays是Java中操作数组的工具类,它提供了大量静态方法来排序、查找、填充、比较数组。

**Arrays的核心功能:**

1. **排序**: 提供多种排序方法。

2. **查找**: 提供二分查找等方法。

3. **填充**: 提供填充数组的方法。

4. **比较**: 提供比较数组的方法。

5. **转换**: 提供数组与List之间的转换。

```java
public class Arrays {
    // 私有构造方法,防止实例化
    private Arrays() {
    }
}
```

#### 6.2.2 排序方法

```java
// 对int数组进行排序
public static void sort(int[] a) {
    DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);
}

// 对int数组的指定范围进行排序
public static void sort(int[] a, int fromIndex, int toIndex) {
    rangeCheck(a.length, fromIndex, toIndex);
    DualPivotQuicksort.sort(a, fromIndex, toIndex - 1, null, 0, 0);
}

// 对Object数组进行排序
public static void sort(Object[] a) {
    if (LegacyMergeSort.userRequested)
        legacyMergeSort(a);
    else
        ComparableTimSort.sort(a, 0, a.length, null, 0, 0);
}

// 使用指定的Comparator对Object数组进行排序
public static <T> void sort(T[] a, Comparator<? super T> c) {
    if (LegacyMergeSort.userRequested)
        legacyMergeSort(a, c);
    else
        TimSort.sort(a, 0, a.length, c, null, 0, 0);
}
```

**排序算法:**

1. **基本类型数组**: 使用双轴快速排序(DualPivotQuicksort)。

2. **对象数组**: 使用TimSort算法,它是归并排序和插入排序的混合。

**排序方法的时间复杂度:**

- 平均情况: O(n log n)
- 最坏情况: O(n log n)

#### 6.2.3 查找方法

```java
// 使用二分查找
public static int binarySearch(int[] a, int key) {
    return binarySearch0(a, 0, a.length, key);
}

// 对int数组的指定范围进行二分查找
public static int binarySearch(int[] a, int fromIndex, int toIndex,
                             int key) {
    rangeCheck(a.length, fromIndex, toIndex);
    return binarySearch0(a, fromIndex, toIndex, key);
}

// 核心二分查找方法
private static int binarySearch0(int[] a, int fromIndex, int toIndex,
                                 int key) {
    int low = fromIndex;
    int high = toIndex - 1;
    
    while (low <= high) {
        int mid = (low + high) >>> 1;
        int midVal = a[mid];
        
        if (midVal < key)
            low = mid + 1;
        else if (midVal > key)
            high = mid - 1;
        else
            return mid;
    }
    return -(low + 1);
}

// 对Object数组进行二分查找
public static int binarySearch(Object[] a, Object key) {
    return binarySearch0(a, 0, a.length, key);
}

// 对Object数组的指定范围进行二分查找
public static <T> int binarySearch(T[] a, int fromIndex, int toIndex,
                                 T key, Comparator<? super T> c) {
    rangeCheck(a.length, fromIndex, toIndex);
    return binarySearch0(a, fromIndex, toIndex, key, c);
}

// 对Object数组进行二分查找的核心方法
private static <T> int binarySearch0(T[] a, int fromIndex, int toIndex,
                                     T key, Comparator<? super T> c) {
    if (c == null) {
        return binarySearch0(a, fromIndex, toIndex, key);
    }
    
    int low = fromIndex;
    int high = toIndex - 1;
    
    while (low <= high) {
        int mid = (low + high) >>> 1;
        T midVal = a[mid];
        int cmp = c.compare(midVal, key);
        
        if (cmp < 0)
            low = mid + 1;
        else if (cmp > 0)
            high = mid - 1;
        else
            return mid;
    }
    return -(low + 1);
}
```

**查找方法的时间复杂度:**

- O(log n) - 二分查找

#### 6.2.4 填充方法

```java
// 使用指定值填充int数组
public static void fill(int[] a, int val) {
    for (int i = 0, len = a.length; i < len; i++)
        a[i] = val;
}

// 对int数组的指定范围进行填充
public static void fill(int[] a, int fromIndex, int toIndex, int val) {
    rangeCheck(a.length, fromIndex, toIndex);
    for (int i = fromIndex; i < toIndex; i++)
        a[i] = val;
}

// 使用指定值填充Object数组
public static void fill(Object[] a, Object val) {
    for (int i = 0, len = a.length; i < len; i++)
        a[i] = val;
}

// 对Object数组的指定范围进行填充
public static void fill(Object[] a, int fromIndex, int toIndex, Object val) {
    rangeCheck(a.length, fromIndex, toIndex);
    for (int i = fromIndex; i < toIndex; i++)
        a[i] = val;
}
```

#### 6.2.5 比较方法

```java
// 比较两个int数组
public static boolean equals(int[] a, int[] a2) {
    if (a==a2)
        return true;
    if (a==null || a2==null)
        return false;
    
    int length = a.length;
    if (a2.length != length)
        return false;
    
    for (int i=0; i<length; i++)
        if (a[i] != a2[i])
            return false;
    
    return true;
}

// 比较两个Object数组
public static boolean equals(Object[] a, Object[] a2) {
    if (a==a2)
        return true;
    if (a==null || a2==null)
        return false;
    
    int length = a.length;
    if (a2.length != length)
        return false;
    
    for (int i=0; i<length; i++) {
        Object o1 = a[i];
        Object o2 = a2[i];
        if (!(o1==null ? o2==null : o1.equals(o2)))
            return false;
    }
    
    return true;
}
```

#### 6.2.6 转换方法

```java
// 将List转换为数组
public static <T> T[] toArray(List<T> list, T[] a) {
    if (list instanceof RandomAccess) {
        if (a.length < list.size()) {
            a = (T[])java.lang.reflect.Array
                .newInstance(a.getClass().getComponentType(), list.size());
        }
        for (int i=0; i<list.size(); i++) {
            a[i] = list.get(i);
        }
        if (a.length > list.size())
            a[list.size()] = null;
        return a;
    } else {
        Object[] arr = list.toArray();
        if (arr.length > a.length)
            throw new ArrayIndexOutOfBoundsException();
        System.arraycopy(arr, 0, a, 0, arr.length);
        if (a.length > arr.length)
            a[arr.length] = null;
        return a;
    }
}

// 返回包含List所有元素的数组
public static <T> T[] toArray(List<T> list) {
    return list.toArray((T[])new Object[0]);
}

// 返回包含数组所有元素的List
public static <T> List<T> asList(T... a) {
    return new ArrayList<>(a);
}

// ArrayList内部实现
private static class ArrayList<E> extends AbstractList<E>
    implements RandomAccess, java.io.Serializable {
    private static final long serialVersionUID = -2764017481108945198L;
    
    private final E[] a;
    
    ArrayList(E[] array) {
        if (array==null)
            throw new NullPointerException();
        a = array;
    }
    
    public int size() {
        return a.length;
    }
    
    public Object[] toArray() {
        return a.clone();
    }
    
    public <T> T[] toArray(T[] a) {
        int size = size();
        if (a.length < size)
            return (T[]) Arrays.copyOf(a, size, a.getClass());
        System.arraycopy(a, 0, a, 0, size);
        if (a.length > size)
            a[size] = null;
        return a;
    }
    
    public E get(int index) {
        return a[index];
    }
    
    public E set(int index, E element) {
        E oldValue = a[index];
        a[index] = element;
        return oldValue;
    }
    
    public int indexOf(Object o) {
        if (o==null) {
            for (int i=0; i<a.length; i++)
                if (a[i]==null)
                    return i;
        } else {
            for (int i=0; i<a.length; i++)
                if (o.equals(a[i]))
                    return i;
        }
        return -1;
    }
    
    public boolean contains(Object o) {
        return indexOf(o) != -1;
    }
}
```

### 6.3 集合工具类使用最佳实践

#### 6.3.1 选择合适的工具方法

```java
// 场景1: 需要排序
List<String> list = new ArrayList<>();
list.add("C");
list.add("A");
list.add("B");
Collections.sort(list);

// 场景2: 需要查找
int index = Collections.binarySearch(list, "B");

// 场景3: 需要线程安全
List<String> syncList = Collections.synchronizedList(list);

// 场景4: 需要不可变集合
List<String> unmodifiableList = Collections.unmodifiableList(list);
```

#### 6.3.2 避免常见错误

**错误1: 修改不可变集合**

```java
// 错误示例
List<String> list = new ArrayList<>();
list.add("A");
List<String> unmodifiableList = Collections.unmodifiableList(list);
unmodifiableList.add("B"); // UnsupportedOperationException

// 正确示例
List<String> list = new ArrayList<>();
list.add("A");
List<String> unmodifiableList = Collections.unmodifiableList(list);
// 修改原集合
list.add("B");
```

**错误2: 迭代同步集合时不同步**

```java
// 错误示例
List<String> syncList = Collections.synchronizedList(new ArrayList<>());
syncList.add("A");
syncList.add("B");

for (String s : syncList) {
    if (s.equals("B")) {
        syncList.remove(s); // 可能抛出异常
    }
}

// 正确示例
synchronized (syncList) {
    for (String s : syncList) {
        if (s.equals("B")) {
            syncList.remove(s);
        }
    }
}
```

#### 6.3.3 性能优化建议

**1. 使用RandomAccess接口**

```java
// 场景1: 实现了RandomAccess接口
List<String> list = new ArrayList<>();
if (list instanceof RandomAccess) {
    // 使用索引访问
    for (int i = 0; i < list.size(); i++) {
        String s = list.get(i);
    }
} else {
    // 使用迭代器
    for (String s : list) {
    }
}
```

**2. 使用空集合**

```java
// 错误示例
List<String> list = new ArrayList<>();

// 正确示例
List<String> list = Collections.emptyList();
```

### 6.4 小结

集合工具类是Java集合框架的重要组成部分,理解其实现原理对于编写高效、正确的代码至关重要。

**核心要点总结:**

第一,**Collections类**: 提供排序、查找、填充、同步、不可变等方法。

第二,**Arrays类**: 提供排序、查找、填充、比较、转换等方法。

第三,**排序算法**: 基本类型使用双轴快速排序,对象类型使用TimSort。

第四,**查找算法**: 使用二分查找,时间复杂度O(log n)。

第五,**同步包装**: 提供线程安全的包装,但迭代器需要手动同步。

第六,**不可变包装**: 提供不可变集合,防止修改。

第七,**最佳实践**: 选择合适的工具方法、避免常见错误、优化性能。
